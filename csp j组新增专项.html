<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP-J专项知识点模拟试卷</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
        }
        .question-card {
            transition: all 0.3s ease;
        }
        .correct {
            border-left: 5px solid #22c55e; /* green-500 */
        }
        .incorrect {
            border-left: 5px solid #ef4444; /* red-500 */
        }
        .correct-option {
            background-color: #dcfce7; /* green-100 */
        }
        .selected-incorrect {
            background-color: #fee2e2; /* red-100 */
            text-decoration: line-through;
        }
        pre code {
            border-radius: 0.5rem;
        }
        .option-label {
            cursor: pointer;
            display: block;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            transition: all 0.2s;
        }
        .option-label:hover {
            background-color: #f3f4f6;
        }
        input[type="radio"]:checked + .option-label {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        .section-title {
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="exam-container" class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-white rounded-xl shadow-lg p-8 mb-8">
            <h1 class="text-3xl font-bold text-center text-blue-600">CSP-J专项知识点模拟试卷</h1>
            <p class="text-center text-gray-500 mt-2">（满分：100分 考试时间：120分钟）</p>
             <div class="mt-6 text-sm text-gray-600 border-l-4 border-blue-400 pl-4">
                <p><strong>考察重点：</strong></p>
                <ul class="list-disc list-inside mt-2">
                    <li>前缀和与差分</li>
                    <li>双指针</li>
                    <li>二分查找</li>
                    <li>快速幂思想</li>
                    <li>01背包</li>
                </ul>
            </div>
        </div>

        <form id="quiz-form">
            <!-- Questions will be injected here by JavaScript -->
        </form>

        <div class="text-center mt-8">
            <button id="submit-btn" type="button" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition duration-300">
                提交试卷
            </button>
        </div>

        <div id="result-container" class="hidden mt-10 bg-white rounded-xl shadow-lg p-8">
            <h2 class="text-2xl font-bold text-center">考试结果</h2>
            <p id="score" class="text-4xl font-bold text-center text-blue-600 my-4"></p>
            <div id="feedback" class="text-center text-lg mb-8"></div>
            <div id="answers-section">
                <h3 class="text-xl font-bold mb-4">答案与解析</h3>
                <div id="answers-display"></div>
            </div>
        </div>

    </div>

    <script>
    const quizData = {
        totalScore: 100,
        sections: [
            {
                title: "一、单项选择题（共15题，每题2分，共计30分）",
                questions: [
                    // General questions
                    { question: "1. 在8位二进制下，-5的原码、反码和补码分别是？", options: ["10000101, 11111010, 11111011", "10000101, 11111010, 11111010", "00000101, 11111010, 11111011", "10000101, 11111011, 11111010"], answer: "10000101, 11111010, 11111011", explanation: "正5的二进制是00000101。原码将最高位设为1得10000101。反码是符号位不变，其余位取反得11111010。补码是反码加1得11111011。" },
                    { question: "2. 下列逻辑运算符中，优先级最高的是？", options: ["&& (逻辑与)", "|| (逻辑或)", "! (逻辑非)", "=="], answer: "! (逻辑非)", explanation: "在C++中，逻辑运算符的优先级从高到低依次是：! (非) > && (与) > || (或)。" },
                    // Specific knowledge points
                    { question: "3. 已知一个数组 a，它的前缀和数组为 s (s[i] = a[0] + ... + a[i-1])。那么，数组 a 在区间 [L, R] (包含L和R) 内的元素之和可以表示为？", options: ["s[R] - s[L]", "s[R+1] - s[L]", "s[R] - s[L-1]", "s[R+1] - s[L-1]"], answer: "s[R+1] - s[L]", explanation: "如果s[i]表示前i个元素的和(从a[0]到a[i-1])，那么a[L]到a[R]的和就是(a[0]到a[R]的和)减去(a[0]到a[L-1]的和)，即 s[R+1] - s[L]。" },
                    { question: "4. 对于一个有序数组，使用二分查找算法查找一个元素的时间复杂度是？", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], answer: "O(log n)", explanation: "二分查找每次都将搜索范围缩小一半，所以查找次数与数组大小n的对数成正比。" },
                    { question: "5. 双指针算法通常用于解决什么问题？", options: ["在无序数组中查找元素", "在有序序列上进行线性时间的区间或配对查找", "计算图的最短路径", "对复杂数据进行排序"], answer: "在有序序列上进行线性时间的区间或配对查找", explanation: "双指针技术通过维护两个指针在线性结构（如数组或链表）上同向或对向移动，来优化查找过程，通常能将O(n²)的暴力枚举优化到O(n)。" },
                    { question: "6. 快速幂算法的核心思想是？", options: ["动态规划", "贪心", "分治与倍增", "搜索剪枝"], answer: "分治与倍增", explanation: "快速幂将a^b中的指数b进行二进制拆分，例如a^13 = a^8 * a^4 * a^1，然后通过反复平方a, a², a⁴, a⁸...来快速计算出结果，体现了倍增和分治的思想。" },
                    { question: "7. 01背包问题中，对于每个物品，有多少种选择策略？", options: ["0种", "1种", "2种", "无限多种"], answer: "2种", explanation: "01背包问题的核心在于每件物品只有两种状态：选（放入背包）或不选（不放入背包）。" },
                    { question: "8. 下列哪项不是差分数组擅长解决的问题？", options: ["对一个区间的数都加上一个常数", "对一个区间的数都减去一个常数", "查询单个元素的值", "频繁查询区间和"], answer: "频繁查询区间和", explanation: "差分数组通过O(1)的操作实现区间加减，但查询单个元素的值需要O(n)的时间计算前缀和。频繁查询区间和是前缀和数组的优势。" },
                    { question: "9. 一棵有n个节点的完全二叉树，其深度最小为？", options: ["log₂(n)", "log₂(n+1)", "floor(log₂(n)) + 1", "ceil(log₂(n))"], answer: "floor(log₂(n)) + 1", explanation: "深度为k的满二叉树有2^k-1个节点。对于n个节点的完全二叉树，其深度h满足 2^(h-1) <= n < 2^h。解这个不等式得到 h = floor(log₂n) + 1。" },
                    { question: "10. 以下C++ STL容器中，哪个是有序的且不允许重复元素？", options: ["vector", "map", "set", "list"], answer: "set", explanation: "std::set基于红黑树实现，它会自动对存入的元素进行排序，并且保证元素的唯一性。" },
                    { question: "11. 广度优先搜索(BFS)通常用于解决图论中的什么问题？", options: ["查找强连通分量", "求解单源最短路径（无权图）", "拓扑排序", "查找割点"], answer: "求解单源最短路径（无权图）", explanation: "BFS按层次遍历图，其性质保证了第一次到达某个节点时的路径就是从源点到该节点的最短路径（在所有边的权重都为1的情况下）。" },
                    { question: "12. 在C++中，`new` 关键字用于？", options: ["创建一个新文件", "声明一个新变量", "在堆上动态分配内存", "调用一个函数"], answer: "在堆上动态分配内存", explanation: "`new` 用于在程序运行时从堆（自由存储区）中申请内存空间，并返回指向该空间的指针。与之对应的是 `delete`，用于释放这块内存。" },
                    { question: "13. 一个栈的入栈序列是 A, B, C, D。下列哪个不可能是它的出栈序列？", options: ["A, B, C, D", "D, C, B, A", "B, A, D, C", "C, D, A, B"], answer: "C, D, A, B", explanation: "要让C出栈，A和B必须已经入栈。要让D出栈，A,B,C,D必须都已入栈，此时栈内从底到顶是A,B。D出栈后，栈顶是C，但下一个出栈的是A，这不可能，因为B在A上面。" },
                    { question: "14. `1TB` 等于多少 `GB`？", options: ["1000", "1024", "2048", "512"], answer: "1024", explanation: "在计算机存储单位中，换算关系通常是2¹⁰，即1TB = 1024GB, 1GB = 1024MB, 1MB = 1024KB。" },
                    { question: "15. P类问题是指？", options: ["无法在多项式时间内解决的问题", "可以在多项式时间内解决的问题", "必须使用概率算法解决的问题", "NP问题的子集"], answer: "可以在多项式时间内解决的问题", explanation: "在计算复杂度理论中，P代表Polynomial time，指的是所有可以由一个确定性图灵机在多项式时间内解决的决策问题的集合。" }
                ]
            },
            {
                title: "二、程序阅读理解题（共2题，共计40分）",
                questions: [
                    {
                        type: "group",
                        description: "<strong>(程序一)</strong> 阅读下面的双指针程序，回答问题。",
                        code: `
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n, target;
    std::cin >> n >> target;
    std::vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }
    std::sort(a.begin(), a.end());
    int i = 0, j = n - 1;
    bool found = false;
    while (i < j) {
        int sum = a[i] + a[j];
        if (sum == target) {
            found = true;
            break;
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    if (found) {
        std::cout << "Yes" << std::endl;
    } else {
        std::cout << "No" << std::endl;
    }
    return 0;
}
                        `,
                        sub_questions: [
                             { id: 16, points: 10, question: "16. 该程序的主要功能是？", options: ["查找数组中的最大值和最小值", "判断数组是否已排序", "在数组中查找是否存在两个数的和等于target", "计算数组所有元素的和"], answer: "在数组中查找是否存在两个数的和等于target", explanation: "程序首先对数组排序，然后使用头尾双指针i和j，通过比较a[i]+a[j]与target的大小关系来移动指针，以O(n)的时间复杂度查找是否存在这样的数对。" },
                             { id: 17, points: 10, question: "17. 如果输入为 `6 10` 和序列 `8 3 5 1 9 4`，程序的输出是？", options: ["Yes", "No", "0", "1"], answer: "Yes", explanation: "序列排序后为 {1, 3, 4, 5, 8, 9}。i=0, j=5, a[0]+a[5]=10, 满足条件，输出Yes。" },
                             { id: 18, points: 10, question: "18. 如果没有 `std::sort` 这一行，该算法的逻辑是否仍然正确？", options: ["正确", "错误", "对某些输入正确", "会导致编译错误"], answer: "错误", explanation: "双指针算法的正确性依赖于数组的有序性。只有在有序的情况下，我们才能通过比较和的大小来确定应该移动哪个指针以逼近目标值。无序数组会导致逻辑判断失效。" }
                        ]
                    },
                    {
                        type: "group",
                        description: "<strong>(程序二)</strong> 阅读下面的前缀和程序，回答问题。",
                        code: `
#include <iostream>
#include <vector>

int main() {
    int n, m;
    std::cin >> n >> m;
    std::vector<int> a(n + 1, 0);
    std::vector<long long> s(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        std::cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    for (int k = 0; k < m; ++k) {
        int l, r;
        std::cin >> l >> r;
        std::cout << s[r] - s[l - 1] << std::endl;
    }
    return 0;
}
                        `,
                        sub_questions: [
                            { id: 19, points: 5, question: "19. 该程序的核心作用是？", options: ["对数组进行多次排序", "高效地回答多个区间和查询", "查找数组中的最大子段和", "更新数组中单个元素的值"], answer: "高效地回答多个区间和查询", explanation: "程序首先预处理出前缀和数组s，然后对于每个查询[l, r]，都可以在O(1)的时间内通过s[r] - s[l-1]计算出区间和，非常高效。" },
                            { id: "20", points: 5, question: "20. 如果输入为 `5 2`，序列 `1 2 3 4 5`，查询 `1 3` 和 `2 5`，程序的输出是？", options: ["6\n14", "6\n15", "5\n14", "5\n15"], answer: "6\n14", explanation: "前缀和数组s为{0, 1, 3, 6, 10, 15}。查询[1,3]的和是s[3]-s[0]=6-0=6。查询[2,5]的和是s[5]-s[1]=15-1=14。" }
                        ]
                    }
                ]
            },
            {
                title: "三、程序填空题（共2题，共计30分）",
                questions: [
                    {
                        type: "fill",
                        description: "<strong>(程序一)</strong> 下面的程序使用二分查找在一个升序数组中查找大于等于x的第一个数的位置。请补全代码。",
                        code: `
#include <iostream>
#include <vector>

int lower_bound_search(const std::vector<int>& a, int x) {
    int left = 0, right = a.size(); // 搜索范围 [left, right)
    while (__(1)__) {
        int mid = left + (right - left) / 2;
        if (a[mid] >= x) {
            right = __(2)__;
        } else {
            left = __(3)__;
        }
    }
    return left;
}

int main() {
    std::vector<int> arr = {1, 3, 3, 5, 8, 8, 10};
    std::cout << lower_bound_search(arr, 3) << std::endl; // 输出 1
    std::cout << lower_bound_search(arr, 8) << std::endl; // 输出 4
    std::cout << lower_bound_search(arr, 9) << std::endl; // 输出 6
    return 0;
}
                        `,
                        blanks: [
                             { id: 21, question: "21. 空缺(1)处应填入？", options: ["left <= right", "left < right - 1", "left < right", "left != right"], answer: "left < right", explanation: "二分查找的循环条件通常是 left < right，表示搜索区间 [left, right) 非空。当 left == right 时，区间为空，搜索结束。" },
                             { id: 22, question: "22. 空缺(2)处应填入？", options: ["mid - 1", "mid", "mid + 1", "left"], answer: "mid", explanation: "如果 a[mid] >= x，说明 mid 位置的数以及它右边的数都有可能是答案，我们需要在左半部分 [left, mid) 继续查找，所以将 right 设为 mid。" },
                             { id: 23, question: "23. 空缺(3)处应填入？", options: ["mid", "mid - 1", "mid + 1", "right"], answer: "mid + 1", explanation: "如果 a[mid] < x，说明 mid 位置的数以及它左边的数一定不是答案，我们需要在右半部分 [mid + 1, right) 继续查找，所以将 left 设为 mid + 1。" }
                        ]
                    },
                    {
                        type: "fill",
                        description: "<strong>(程序二)</strong> 下面的程序实现了01背包问题。请补全代码。",
                        code: `
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int N, V; // 物品数量和背包容量
    cin >> N >> V;
    vector<int> c(N), w(N); // 体积和价值
    for(int i = 0; i < N; ++i) cin >> c[i] >> w[i];
    
    vector<int> dp(V + 1, 0);

    for (int i = 0; i < N; ++i) {
        for (int j = V; j >= c[i]; --j) {
            dp[j] = max(__(1)__, __(2)__);
        }
    }
    
    cout << __(3)__ << endl;
    return 0;
}
                        `,
                        blanks: [
                            { id: 24, question: "24. 空缺(1)处应填入？", options: ["dp[j-1]", "dp[j]", "dp[j - c[i]]", "0"], answer: "dp[j]", explanation: "状态转移方程表示决策。这一项代表“不选第i个物品”，那么对于容量为j的背包，其最大价值依然是之前计算出的dp[j]。" },
                            { id: 25, question: "25. 空缺(2)处应填入？", options: ["dp[j - w[i]] + c[i]", "dp[j - 1] + w[i]", "dp[j - c[i]] + w[i]", "dp[V]"], answer: "dp[j - c[i]] + w[i]", explanation: "这一项代表“选择第i个物品”。那么就需要从容量为 j-c[i] 的背包状态转移而来，其价值是 dp[j-c[i]] 加上当前物品i的价值w[i]。" },
                            { id: 26, question: "26. 空缺(3)处应填入？", options: ["dp[0]", "dp[N]", "dp[V]", "dp[V-1]"], answer: "dp[V]", explanation: "dp数组的定义是dp[j]表示容量为j的背包能装下的最大价值。当所有物品都决策完后，dp[V]自然就是最终答案。" }
                        ]
                    }
                ]
            }
        ]
    };
    
    document.addEventListener('DOMContentLoaded', function () {
        const form = document.getElementById('quiz-form');
        let questionCounter = 0;
        
        quizData.sections.forEach(section => {
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'text-2xl font-bold text-gray-700 section-title';
            sectionTitle.textContent = section.title;
            form.appendChild(sectionTitle);

            section.questions.forEach(q => {
                const questionContainer = document.createElement('div');
                questionContainer.className = 'bg-white rounded-xl shadow-lg p-6 mb-6 question-card';
                
                if (q.type === 'group' || q.type === 'fill') {
                     const description = document.createElement('p');
                     description.innerHTML = q.description;
                     description.className = 'text-gray-700 text-lg mb-4';
                     questionContainer.appendChild(description);

                     if(q.code) {
                        const codeBlock = document.createElement('pre');
                        codeBlock.className = 'bg-gray-800 text-white p-4 rounded-lg text-sm mb-4 overflow-x-auto';
                        const code = document.createElement('code');
                        code.textContent = q.code.trim();
                        codeBlock.appendChild(code);
                        questionContainer.appendChild(codeBlock);
                     }
                     
                     (q.sub_questions || q.blanks).forEach(sub_q => {
                        questionCounter++;
                        const subQuestionDiv = document.createElement('div');
                        subQuestionDiv.className = 'mt-4 border-t pt-4';
                        subQuestionDiv.id = `q-container-${sub_q.id}`;
                        const subQuestionText = document.createElement('p');
                        subQuestionText.className = 'font-semibold mb-3';
                        subQuestionText.textContent = sub_q.question;
                        subQuestionDiv.appendChild(subQuestionText);

                        sub_q.options.forEach((opt, index) => {
                            const optionWrapper = document.createElement('div');
                            optionWrapper.className = 'mb-2';
                            const radio = document.createElement('input');
                            radio.type = 'radio';
                            radio.name = `question-${sub_q.id}`;
                            radio.value = opt;
                            radio.id = `q${sub_q.id}-opt${index}`;
                            radio.className = 'hidden';

                            const label = document.createElement('label');
                            label.htmlFor = `q${sub_q.id}-opt${index}`;
                            label.textContent = `${String.fromCharCode(65 + index)}. ${opt}`;
                            label.className = 'option-label';

                            optionWrapper.appendChild(radio);
                            optionWrapper.appendChild(label);
                            subQuestionDiv.appendChild(optionWrapper);
                        });
                        questionContainer.appendChild(subQuestionDiv);
                     });

                } else {
                    questionCounter++;
                    questionContainer.id = `q-container-${questionCounter}`;
                    const questionText = document.createElement('p');
                    questionText.className = 'font-semibold text-lg mb-4';
                    questionText.textContent = q.question;
                    questionContainer.appendChild(questionText);

                    q.options.forEach((opt, index) => {
                        const optionWrapper = document.createElement('div');
                        optionWrapper.className = 'mb-2';
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = `question-${questionCounter}`;
                        radio.value = opt;
                        radio.id = `q${questionCounter}-opt${index}`;
                        radio.className = 'hidden';
                        
                        const label = document.createElement('label');
                        label.htmlFor = `q${questionCounter}-opt${index}`;
                        label.textContent = `${String.fromCharCode(65 + index)}. ${opt}`;
                        label.className = 'option-label';
                        
                        optionWrapper.appendChild(radio);
                        optionWrapper.appendChild(label);
                        questionContainer.appendChild(optionWrapper);
                    });
                }
                form.appendChild(questionContainer);
            });
        });

        document.getElementById('submit-btn').addEventListener('click', () => {
             let totalScore = 0;
             const answersDisplay = document.getElementById('answers-display');
             answersDisplay.innerHTML = '';
             let questionIndex = 0;
             
             quizData.sections.forEach(section => {
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-xl font-bold mt-6 mb-2 text-blue-600';
                sectionTitle.textContent = section.title;
                answersDisplay.appendChild(sectionTitle);

                section.questions.forEach(q => {
                    if (q.type === 'group' || q.type === 'fill') {
                        (q.sub_questions || q.blanks).forEach(sub_q => {
                            let points = sub_q.points || 5;
                            if (section.title.includes('程序阅读理解题')) points = 10;
                            const qContainer = document.getElementById(`q-container-${sub_q.id}`);
                            const userAnswer = form.querySelector(`input[name="question-${sub_q.id}"]:checked`);
                            const isCorrect = userAnswer && userAnswer.value === sub_q.answer;
                            if (isCorrect) {
                                totalScore += points;
                                qContainer.classList.add('correct');
                            } else {
                                qContainer.classList.add('incorrect');
                                if (userAnswer) {
                                    userAnswer.nextElementSibling.classList.add('selected-incorrect');
                                }
                            }
                            const explanation = document.createElement('div');
                            explanation.className = 'mt-2 p-3 bg-gray-100 rounded-md text-sm';
                            explanation.innerHTML = `<strong class="text-blue-700">正确答案: ${sub_q.answer}</strong><p class="mt-1">${sub_q.explanation}</p>`;
                            
                            const correctOptionLabel = Array.from(qContainer.querySelectorAll('label')).find(l => l.textContent.includes(sub_q.answer));
                            if (correctOptionLabel) { correctOptionLabel.classList.add('correct-option'); }
                            
                            qContainer.appendChild(explanation);
                        });
                    } else {
                        questionIndex++;
                        let points = 2;
                        const qContainer = document.getElementById(`q-container-${questionIndex}`);
                        const userAnswer = form.querySelector(`input[name="question-${questionIndex}"]:checked`);
                        const isCorrect = userAnswer && userAnswer.value === q.answer;
                         if (isCorrect) {
                            totalScore += points;
                            qContainer.classList.add('correct');
                        } else {
                            qContainer.classList.add('incorrect');
                             if (userAnswer) {
                                userAnswer.nextElementSibling.classList.add('selected-incorrect');
                            }
                        }
                        const explanation = document.createElement('div');
                        explanation.className = 'mt-2 p-3 bg-gray-100 rounded-md text-sm';
                        explanation.innerHTML = `<strong class="text-blue-700">正确答案: ${q.answer}</strong><p class="mt-1">${q.explanation}</p>`;

                        const correctOptionLabel = Array.from(qContainer.querySelectorAll('label')).find(l => l.textContent.includes(q.answer));
                        if(correctOptionLabel) { correctOptionLabel.classList.add('correct-option'); }

                        qContainer.appendChild(explanation);
                    }
                });
             });
             
            document.getElementById('score').textContent = `${totalScore} / 100`;
            const feedback = document.getElementById('feedback');
            if (totalScore >= 90) { feedback.textContent = "太棒了！你真是个编程天才！"; feedback.className = 'text-center text-lg mb-8 text-green-600 font-semibold';
            } else if (totalScore >= 70) { feedback.textContent = "非常不错！继续努力，你很有潜力！"; feedback.className = 'text-center text-lg mb-8 text-blue-600 font-semibold';
            } else if (totalScore >= 60) { feedback.textContent = "成绩合格！在薄弱环节多下功夫，你会更棒！"; feedback.className = 'text-center text-lg mb-8 text-yellow-600 font-semibold';
            } else { feedback.textContent = "别灰心，这只是一个开始。认真分析错题，你会进步的！"; feedback.className = 'text-center text-lg mb-8 text-red-600 font-semibold'; }
            document.getElementById('result-container').classList.remove('hidden');
            document.getElementById('submit-btn').style.display = 'none';

            form.querySelectorAll('input[type="radio"]').forEach(input => { input.disabled = true; });
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    });
    </script>
</body>
</html>
