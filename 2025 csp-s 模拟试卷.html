<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>童澄2025CSP-S信息学奥赛初赛模拟试卷</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
        }
        .question-card {
            transition: all 0.3s ease;
        }
        .correct {
            border-left: 5px solid #22c55e; /* green-500 */
        }
        .incorrect {
            border-left: 5px solid #ef4444; /* red-500 */
        }
        .correct-option {
            background-color: #dcfce7; /* green-100 */
        }
        .selected-incorrect {
            background-color: #fee2e2; /* red-100 */
            text-decoration: line-through;
        }
        pre code {
            border-radius: 0.5rem;
        }
        .option-label {
            cursor: pointer;
            display: block;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            transition: all 0.2s;
        }
        .option-label:hover {
            background-color: #f3f4f6;
        }
        input[type="radio"]:checked + .option-label {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        .section-title {
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="exam-container" class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-white rounded-xl shadow-lg p-8 mb-8">
            <h1 class="text-3xl font-bold text-center text-blue-600">童澄2025CSP-S信息学奥赛初赛模拟试卷</h1>
            <p class="text-center text-gray-500 mt-2">（满分：100分 考试时间：120分钟）</p>
            <div class="mt-6 text-sm text-gray-600 border-l-4 border-blue-400 pl-4">
                <p><strong>考生须知：</strong></p>
                <ul class="list-disc list-inside mt-2">
                    <li>本试卷共三大题，请在指定位置作答。</li>
                    <li>所有选择题均为单项选择，多选、不选或错选均不得分。</li>
                    <li>程序代码均为C++语言。</li>
                    <li>考试结束后，点击“提交试卷”按钮查看分数和解析。</li>
                </ul>
            </div>
        </div>

        <form id="quiz-form">
            <!-- Questions will be injected here by JavaScript -->
        </form>

        <div class="text-center mt-8">
            <button id="submit-btn" type="button" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition duration-300">
                提交试卷
            </button>
        </div>

        <div id="result-container" class="hidden mt-10 bg-white rounded-xl shadow-lg p-8">
            <h2 class="text-2xl font-bold text-center">考试结果</h2>
            <p id="score" class="text-4xl font-bold text-center text-blue-600 my-4"></p>
            <div id="feedback" class="text-center text-lg mb-8"></div>
            <div id="answers-section">
                <h3 class="text-xl font-bold mb-4">答案与解析</h3>
                <div id="answers-display"></div>
            </div>
        </div>

    </div>

    <script>
    const quizData = {
        totalScore: 100,
        sections: [
            {
                title: "一、单项选择题（共15题，每题2分，共计30分）",
                questions: [
                    {
                        question: "1. 在 C++ 中，`std::vector` 的 `capacity()` 方法返回的是？",
                        options: ["向量中元素的数量", "向量中第一个元素的值", "向量在重新分配内存之前可以容纳的元素数量", "向量占用的总字节数"],
                        answer: "向量在重新分配内存之前可以容纳的元素数量",
                        explanation: "`size()` 返回向量中当前元素的数量，而 `capacity()` 返回的是当前已分配存储空间的大小，通常 `capacity() >= size()`。"
                    },
                    {
                        question: "2. 对于一个有向无环图（DAG），其拓扑排序的结果是？",
                        options: ["唯一的", "不唯一的", "最多有两种", "取决于起始顶点"],
                        answer: "不唯一的",
                        explanation: "如果一个DAG中存在多个入度为0的顶点，那么拓扑排序的起始选择就不同，从而可能产生多种不同的拓扑序列。例如，A->C, B->C，拓扑序列可以是 A,B,C 或 B,A,C。"
                    },
                    {
                        question: "3. 在使用Dijkstra算法求单源最短路径时，如果图中存在负权边，算法可能会？",
                        options: ["正常工作", "陷入死循环", "得到错误的结果", "时间复杂度增加"],
                        answer: "得到错误的结果",
                        explanation: "Dijkstra算法基于贪心策略，每次都选择当前最近的顶点进行扩展。这个策略成立的前提是边的权重都是非负的。一旦有负权边，先出队的顶点的最短路长度就可能被后出队的顶点更新，导致结果错误。"
                    },
                    {
                        question: "4. 求解模线性方程 `ax ≡ b (mod m)`，该方程有解的充要条件是？",
                        options: ["a, m 互质", "b, m 互质", "gcd(a, m) 整除 b", "gcd(b, m) 整除 a"],
                        answer: "gcd(a, m) 整除 b",
                        explanation: "根据裴蜀定理，方程 `ax + my = b` 有整数解的充要条件是 `gcd(a, m)` 能整除 `b`。而模线性方程 `ax ≡ b (mod m)` 可以变形为 `ax - b = my`，即 `ax - my = b`，因此条件相同。"
                    },
                    {
                        question: "5. 在 C++ STL 中，`std::map` 和 `std::unordered_map` 的主要区别在于？",
                        options: ["前者是有序的，后者是无序的", "前者键值唯一，后者可以重复", "前者只能用基本类型作键，后者可以自定义", "前者查找快，后者插入快"],
                        answer: "前者是有序的，后者是无序的",
                        explanation: "`std::map` 的底层实现是红黑树，它能保证元素按键自动排序。`std::unordered_map` 的底层实现是哈希表，元素是无序的，但平均查找、插入、删除的时间复杂度为 O(1)。"
                    },
                    {
                        question: "6. 在Linux环境下，用于编译C++程序的常用命令是？",
                        options: ["gcc", "g++", "java", "python"],
                        answer: "g++",
                        explanation: "`gcc` 是GNU C语言编译器，而 `g++` 是GNU C++编译器。虽然 `gcc` 也能编译C++文件（通过特定选项），但 `g++` 会自动链接C++标准库，是更常用和直接的选择。"
                    },
                    {
                        question: "7. KMP算法中的next数组（或称fail数组）`next[i]` 的含义是？",
                        options: ["模式串中第i个字符下一次应该匹配的位置", "模式串的子串[0...i-1]中最长公共前后缀的长度", "模式串中第i个字符在主串中出现的位置", "模式串中与第i个字符相同的上一个字符的位置"],
                        answer: "模式串的子串[0...i-1]中最长公共前后缀的长度",
                        explanation: "next数组是KMP算法的核心，`next[i]` 存储的是模式串P的前i个字符组成的子串 `P[0...i-1]` 中，最长的相等的前缀和后缀的长度。这用于在匹配失败时决定模式串应该向右移动多少位。"
                    },
                    {
                        question: "8. 递归函数 `T(n) = 2T(n/2) + O(n)` 的时间复杂度是？",
                        options: ["O(n)", "O(n log n)", "O(n²)", "O(2ⁿ)"],
                        answer: "O(n log n)",
                        explanation: "这是一个典型的主定理（Master Theorem）应用场景。根据主定理，`a=2, b=2, f(n)=O(n)`。计算 `log_b(a) = log_2(2) = 1`。因为 `f(n) = Θ(n^log_b(a))`，所以 `T(n) = O(n log n)`。这也是归并排序的时间复杂度。 "
                    },
                    {
                        question: "9. 欧拉路径是指图G中的一条路径，该路径恰好只经过G中的每条边一次。一个无向连通图存在欧拉路径的充要条件是？",
                        options: ["所有顶点的度数都是偶数", "度数为奇数的顶点数量为0或2", "所有顶点的度数都是奇数", "图是完全图"],
                        answer: "度数为奇数的顶点数量为0或2",
                        explanation: "如果图中奇数度顶点的数量为0，则存在欧拉回路（起点和终点相同的欧拉路径）。如果奇数度顶点的数量为2，则存在以这两个顶点为起点和终点的欧拉路径。其他情况均不存在欧拉路径。"
                    },
                    {
                        question: "10. 以下哪项操作是并查集（Disjoint Set Union）不支持的？",
                        options: ["合并两个集合", "查询两个元素是否在同一集合", "查询某个集合中的元素个数", "删除某个集合"],
                        answer: "删除某个集合",
                        explanation: "标准的并查集主要支持 `union`（合并）和 `find`（查找代表元）两种操作。虽然可以通过维护 `size` 数组来查询集合元素个数，但它不支持高效的删除集合或从集合中删除单个元素的操作。"
                    },
                    {
                        question: "11. 在一个有 n 个节点的完全图中，边的数量是？",
                        options: ["n-1", "n", "n * (n-1) / 2", "n²"],
                        answer: "n * (n-1) / 2",
                        explanation: "完全图是指图中任意两个不同的顶点之间都恰好有一条边相连。从n个顶点中任选2个顶点组成一条边，共有 C(n, 2) = n * (n-1) / 2 种选法。"
                    },
                    {
                        question: "12. 状态压缩动态规划通常在什么情况下使用？",
                        options: ["数据规模非常大时", "状态转移方程复杂时", "问题涉及到对一个集合的子集进行操作时", "需要优化空间复杂度时"],
                        answer: "问题涉及到对一个集合的子集进行操作时",
                        explanation: "当问题的数据规模较小（例如n <= 20），且需要记录一个集合中每个元素被选取与否的状态时，可以用一个整数的二进制位来表示这个集合的状态，从而将状态压缩成一个整数进行DP。"
                    },
                    {
                        question: "13. 已知费马小定理：若 p 是质数，a 是任意整数且 a 不能被 p 整除，则有 `a^(p-1) ≡ 1 (mod p)`。那么 7¹⁰⁰ mod 11 的结果是？",
                        options: ["1", "3", "7", "9"],
                        answer: "1",
                        explanation: "根据费马小定理，因为11是质数且7不能被11整除，所以 `7¹⁰ ≡ 1 (mod 11)`。因此，`7¹⁰⁰ = (7¹⁰)¹⁰ ≡ 1¹⁰ (mod 11) ≡ 1 (mod 11)`。"
                    },
                    {
                        question: "14. 在C++中，`#include <iostream>` 和 `#include \"myheader.h\"` 的区别是？",
                        options: ["前者是标准库，后者是自定义头文件", "前者用于输入，后者用于输出", "前者在系统目录中查找，后者通常先在当前目录中查找", "没有区别"],
                        answer: "前者在系统目录中查找，后者通常先在当前目录中查找",
                        explanation: "使用尖括号 `<>`，编译器会直接在系统指定的标准库路径下查找头文件。使用双引号 `\"\"`，编译器通常会先在源文件所在的当前目录下查找，如果找不到，再去系统标准库路径下查找。"
                    },
                    {
                        question: "15. 一个栈的入栈序列为 1, 2, 3, 4, 5，则不可能的出栈序列是？",
                        options: ["1, 2, 3, 4, 5", "5, 4, 3, 2, 1", "3, 4, 2, 5, 1", "3, 5, 1, 2, 4"],
                        answer: "3, 5, 1, 2, 4",
                        explanation: "分析D选项：为了让5出栈，必须1,2,3,4,5都入栈。此时栈顶是5，可以出栈。然后栈顶是4，下一个出栈的必须是4，但序列要求是1。所以这是不可能的。栈的规则是后进先出，一个元素一旦被压在另一个元素之下，就必须等上面的元素都出栈后才能出栈。"
                    }
                ]
            },
            {
                title: "二、程序阅读理解题（共2题，每题包含若干小题，共计40分）",
                questions: [
                    {
                        type: "group",
                        description: "<strong>(程序一)</strong> 阅读下面的程序，回答第16-18题。",
                        code: `
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    int n, m;
    std::cin >> n >> m;
    std::vector<int> p(n);
    std::iota(p.begin(), p.end(), 0);
    
    auto find = [&](int x) {
        int root = x;
        while (p[root] != root) {
            root = p[root];
        }
        while (p[x] != root) {
            int parent = p[x];
            p[x] = root;
            x = parent;
        }
        return root;
    };

    for (int i = 0; i < m; ++i) {
        int u, v;
        std::cin >> u >> v;
        int root_u = find(u);
        int root_v = find(v);
        if (root_u != root_v) {
            p[root_u] = root_v;
        }
    }

    int components = 0;
    for (int i = 0; i < n; ++i) {
        if (p[i] == i) {
            components++;
        }
    }
    std::cout << components << std::endl;

    return 0;
}
                        `,
                        sub_questions: [
                             {
                                id: 16,
                                points: 10,
                                question: "16. 该程序实现的核心数据结构是？",
                                options: ["栈", "队列", "并查集", "二叉树"],
                                answer: "并查集",
                                explanation: "程序通过 `p` 数组维护一个森林，`find` 函数用于查找元素的根节点（带有路径压缩优化），并在循环中合并集合。这是典型的并查集（Disjoint Set Union）数据结构。"
                            },
                             {
                                id: 17,
                                points: 10,
                                question: "17. 程序最后输出的 `components` 变量的含义是？",
                                options: ["边的数量", "顶点的数量", "连通分量的数量", "环的数量"],
                                answer: "连通分量的数量",
                                explanation: "并查集用于维护和查询图的连通性。每个集合代表一个连通分量。程序最后遍历所有节点，计算根节点（`p[i] == i`）的数量，这正是图中连通分量的数量。"
                            },
                             {
                                id: 18,
                                points: 10,
                                question: "18. 如果输入为 `6 4`，接着输入四行 `0 1`, `1 2`, `3 4`, `4 5`，程序的输出是？",
                                options: ["1", "2", "3", "4"],
                                answer: "2",
                                explanation: "输入表示有6个节点(0-5)和4条边。边(0,1)和(1,2)将{0,1,2}连接成一个连通分量。边(3,4)和(4,5)将{3,4,5}连接成另一个连通分量。因此，图中总共有2个连通分量。"
                            }
                        ]
                    },
                    {
                        type: "group",
                        description: "<strong>(程序二)</strong> 阅读下面的程序，回答第19-20题。",
                        code: `
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    
    if (n == 0) {
        cout << 0 << endl;
        return 0;
    }
    
    vector<int> d;
    d.push_back(a[0]);

    for (int i = 1; i < n; ++i) {
        if (a[i] > d.back()) {
            d.push_back(a[i]);
        } else {
            *lower_bound(d.begin(), d.end(), a[i]) = a[i];
        }
    }
    
    cout << d.size() << endl;
    
    return 0;
}
                        `,
                        sub_questions: [
                            {
                                id: 19,
                                points: 5,
                                question: "19. 该程序解决的问题是？",
                                options: ["最长公共子序列", "最长递增子序列", "序列排序", "查找中位数"],
                                answer: "最长递增子序列",
                                explanation: "该程序实现了一种求解最长递增子序列（LIS）长度的经典优化算法。它维护一个数组 `d`，其中 `d[i]` 表示长度为 `i+1` 的所有递增子序列中末尾元素的最小值。"
                            },
                             {
                                id: 20,
                                points: 5,
                                question: "20. 如果输入为 `8` 和序列 `3 1 4 1 5 9 2 6`，程序的输出是？",
                                options: ["3", "4", "5", "6"],
                                answer: "4",
                                explanation: "追踪 `d` 数组的变化：\n1. `a[0]=3`, d={3}\n2. `a[1]=1`, 1<3, d={1}\n3. `a[2]=4`, 4>1, d={1,4}\n4. `a[3]=1`, 1<=1, d={1,4}\n5. `a[4]=5`, 5>4, d={1,4,5}\n6. `a[5]=9`, 9>5, d={1,4,5,9}\n7. `a[6]=2`, 2>1, d={1,2,5,9}\n8. `a[7]=6`, 6>5, d={1,2,5,6}\n最终 `d` 的大小为4。一个LIS是 {1, 2, 5, 6}。"
                            }
                        ]
                    }
                ]
            },
            {
                title: "三、程序填空题（共2题，每空5分，共计30分）",
                questions: [
                    {
                        type: "fill",
                        description: "<strong>(程序一)</strong> 下面的程序使用分治法实现了快速排序算法。请补全代码。",
                        code: `
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int partition(vector<int>& a, int low, int high) {
    int pivot = a[high];
    int i = low - 1;
    for (int j = low; j < high; ++j) {
        if (a[j] < pivot) {
            i++;
            __(1)__;
        }
    }
    swap(a[i + 1], a[high]);
    return __(2)__;
}

void quickSort(vector<int>& a, int low, int high) {
    if (low < high) {
        int pi = partition(a, low, high);
        quickSort(a, low, __(3)__);
        quickSort(a, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    quickSort(arr, 0, arr.size() - 1);
    for (int x : arr) cout << x << " "; // 1 5 7 8 9 10
    cout << endl;
    return 0;
}
                        `,
                        blanks: [
                             {
                                id: 21,
                                question: "21. 空缺(1)处应填入？",
                                options: ["swap(a[i], a[j])", "swap(a[i], pivot)", "a[i] = a[j]", "a[j] = a[i]"],
                                answer: "swap(a[i], a[j])",
                                explanation: "这是Lomuto分区方案。`i` 指向小于基准值 `pivot` 的区域的末尾。当发现一个新的小于 `pivot` 的元素 `a[j]` 时，需要将 `i` 后移一位，然后将 `a[j]` 与 `a[i]` 交换，从而扩大这个“小于”区域。"
                            },
                             {
                                id: 22,
                                question: "22. 空缺(2)处应填入？",
                                options: ["i", "i + 1", "high", "low"],
                                answer: "i + 1",
                                explanation: "循环结束后，`i+1` 是基准值 `pivot` 应该在的位置。`swap(a[i + 1], a[high])` 将基准值放到了正确的位置。函数需要返回这个基准值的最终索引。"
                            },
                             {
                                id: 23,
                                question: "23. 空缺(3)处应填入？",
                                options: ["pi", "pi - 1", "pi + 1", "high"],
                                answer: "pi - 1",
                                explanation: "分区操作完成后，索引为 `pi` 的元素已经就位。接下来需要对基准值左边的子数组（从 `low`到`pi - 1`）和右边的子数组（从`pi + 1`到`high`）分别进行递归排序。"
                            }
                        ]
                    },
                    {
                        type: "fill",
                        description: "<strong>(程序二)</strong> 下面的程序实现了Dijkstra算法，用于计算图中从源点 `src` 到所有其他点的最短路径。该实现使用了优先队列进行优化。请补全代码。",
                        code: `
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int INF = 1e9;

void dijkstra(int src, int n, const vector<vector<pair<int, int>>>& adj) {
    vector<int> dist(n, INF);
    dist[src] = 0;
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({__(1)__, src});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist[u]) {
            continue;
        }

        for (auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[u] + weight < __(2)__) {
                dist[v] = __(3)__;
                pq.push({dist[v], v});
            }
        }
    }
    
    for (int i = 0; i < n; ++i) {
        cout << "dist(" << src << ", " << i << ") = " << dist[i] << endl;
    }
}

int main() {
    // A simple graph with 3 nodes
    int n = 3;
    vector<vector<pair<int, int>>> adj(n);
    adj[0].push_back({1, 1});
    adj[0].push_back({2, 4});
    adj[1].push_back({2, 2});
    dijkstra(0, n, adj);
    return 0;
}
                        `,
                        blanks: [
                            {
                                id: 24,
                                question: "24. 空缺(1)处应填入？",
                                options: ["src", "0", "INF", "dist[src]"],
                                answer: "0",
                                explanation: "优先队列 `pq` 存储的是 `{distance, vertex}` 对。我们使用 `greater` 使其成为一个最小堆（按距离从小到大排序）。算法从源点 `src` 开始，源点到自身的距离是0，所以初始时将 `{0, src}` 放入队列。"
                            },
                            {
                                id: 25,
                                question: "25. 空缺(2)处应填入？",
                                options: ["dist[u]", "dist[v]", "INF", "d"],
                                answer: "dist[v]",
                                explanation: "这里是松弛操作。如果通过当前节点 `u` 到达其邻居 `v` 的路径 `dist[u] + weight` 比当前已知的到 `v` 的最短路径 `dist[v]` 更短，那么我们就找到了一个更优的路径。"
                            },
                             {
                                id: 26,
                                question: "26. 空缺(3)处应填入？",
                                options: ["dist[u] + weight", "dist[v]", "d + weight", "weight"],
                                answer: "dist[u] + weight",
                                explanation: "一旦发现更短的路径，就需要更新 `dist[v]` 的值为这个更短的路径长度，即 `dist[u] + weight`，并将更新后的 `{dist[v], v}` 放入优先队列中，以便后续从此节点出发继续寻找最短路径。"
                            }
                        ]
                    }
                ]
            }
        ]
    };
    
    document.addEventListener('DOMContentLoaded', function () {
        const form = document.getElementById('quiz-form');
        let questionCounter = 0;
        
        quizData.sections.forEach(section => {
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'text-2xl font-bold text-gray-700 section-title';
            sectionTitle.textContent = section.title;
            form.appendChild(sectionTitle);

            section.questions.forEach(q => {
                const questionContainer = document.createElement('div');
                questionContainer.className = 'bg-white rounded-xl shadow-lg p-6 mb-6 question-card';
                
                if (q.type === 'group' || q.type === 'fill') {
                     const description = document.createElement('p');
                     description.innerHTML = q.description;
                     description.className = 'text-gray-700 text-lg mb-4';
                     questionContainer.appendChild(description);

                     if(q.code) {
                        const codeBlock = document.createElement('pre');
                        codeBlock.className = 'bg-gray-800 text-white p-4 rounded-lg text-sm mb-4 overflow-x-auto';
                        const code = document.createElement('code');
                        code.textContent = q.code.trim();
                        codeBlock.appendChild(code);
                        questionContainer.appendChild(codeBlock);
                     }
                     
                     (q.sub_questions || q.blanks).forEach(sub_q => {
                        questionCounter++;
                        const subQuestionDiv = document.createElement('div');
                        subQuestionDiv.className = 'mt-4 border-t pt-4';
                        subQuestionDiv.id = `q-container-${sub_q.id}`;
                        const subQuestionText = document.createElement('p');
                        subQuestionText.className = 'font-semibold mb-3';
                        subQuestionText.textContent = sub_q.question;
                        subQuestionDiv.appendChild(subQuestionText);

                        sub_q.options.forEach((opt, index) => {
                            const optionWrapper = document.createElement('div');
                            optionWrapper.className = 'mb-2';
                            const radio = document.createElement('input');
                            radio.type = 'radio';
                            radio.name = `question-${sub_q.id}`;
                            radio.value = opt;
                            radio.id = `q${sub_q.id}-opt${index}`;
                            radio.className = 'hidden';

                            const label = document.createElement('label');
                            label.htmlFor = `q${sub_q.id}-opt${index}`;
                            label.textContent = `${String.fromCharCode(65 + index)}. ${opt}`;
                            label.className = 'option-label';

                            optionWrapper.appendChild(radio);
                            optionWrapper.appendChild(label);
                            subQuestionDiv.appendChild(optionWrapper);
                        });
                        questionContainer.appendChild(subQuestionDiv);
                     });

                } else {
                    questionCounter++;
                    questionContainer.id = `q-container-${questionCounter}`;
                    const questionText = document.createElement('p');
                    questionText.className = 'font-semibold text-lg mb-4';
                    questionText.textContent = q.question;
                    questionContainer.appendChild(questionText);

                    q.options.forEach((opt, index) => {
                        const optionWrapper = document.createElement('div');
                        optionWrapper.className = 'mb-2';
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = `question-${questionCounter}`;
                        radio.value = opt;
                        radio.id = `q${questionCounter}-opt${index}`;
                        radio.className = 'hidden';
                        
                        const label = document.createElement('label');
                        label.htmlFor = `q${questionCounter}-opt${index}`;
                        label.textContent = `${String.fromCharCode(65 + index)}. ${opt}`;
                        label.className = 'option-label';
                        
                        optionWrapper.appendChild(radio);
                        optionWrapper.appendChild(label);
                        questionContainer.appendChild(optionWrapper);
                    });
                }
                form.appendChild(questionContainer);
            });
        });

        document.getElementById('submit-btn').addEventListener('click', () => {
             let totalScore = 0;
             const answersDisplay = document.getElementById('answers-display');
             answersDisplay.innerHTML = '';
             let questionIndex = 0;
             
             quizData.sections.forEach(section => {
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-xl font-bold mt-6 mb-2 text-blue-600';
                sectionTitle.textContent = section.title;
                answersDisplay.appendChild(sectionTitle);

                section.questions.forEach(q => {
                    if (q.type === 'group' || q.type === 'fill') {
                        (q.sub_questions || q.blanks).forEach(sub_q => {
                            let points = sub_q.points || 5;
                            const qContainer = document.getElementById(`q-container-${sub_q.id}`);
                            const userAnswer = form.querySelector(`input[name="question-${sub_q.id}"]:checked`);
                            const isCorrect = userAnswer && userAnswer.value === sub_q.answer;
                            if (isCorrect) {
                                totalScore += points;
                                qContainer.classList.add('correct');
                            } else {
                                qContainer.classList.add('incorrect');
                                if (userAnswer) {
                                    userAnswer.nextElementSibling.classList.add('selected-incorrect');
                                }
                            }
                            // Show explanation
                            const explanation = document.createElement('div');
                            explanation.className = 'mt-2 p-3 bg-gray-100 rounded-md text-sm';
                            explanation.innerHTML = `<strong class="text-blue-700">正确答案: ${sub_q.answer}</strong><p class="mt-1">${sub_q.explanation}</p>`;
                            
                            const correctOptionLabel = Array.from(qContainer.querySelectorAll('label')).find(l => l.textContent.includes(sub_q.answer));
                            if (correctOptionLabel) {
                                correctOptionLabel.classList.add('correct-option');
                            }
                            
                            qContainer.appendChild(explanation);
                        });
                    } else {
                        questionIndex++;
                        let points = 2; // Single choice questions
                        const qContainer = document.getElementById(`q-container-${questionIndex}`);
                        const userAnswer = form.querySelector(`input[name="question-${questionIndex}"]:checked`);
                        const isCorrect = userAnswer && userAnswer.value === q.answer;
                         if (isCorrect) {
                            totalScore += points;
                            qContainer.classList.add('correct');
                        } else {
                            qContainer.classList.add('incorrect');
                             if (userAnswer) {
                                userAnswer.nextElementSibling.classList.add('selected-incorrect');
                            }
                        }
                        // Show explanation
                        const explanation = document.createElement('div');
                        explanation.className = 'mt-2 p-3 bg-gray-100 rounded-md text-sm';
                        explanation.innerHTML = `<strong class="text-blue-700">正确答案: ${q.answer}</strong><p class="mt-1">${q.explanation}</p>`;

                        const correctOptionLabel = Array.from(qContainer.querySelectorAll('label')).find(l => l.textContent.includes(q.answer));
                        if(correctOptionLabel) {
                            correctOptionLabel.classList.add('correct-option');
                        }

                        qContainer.appendChild(explanation);
                    }
                });
             });
             
            document.getElementById('score').textContent = `${totalScore} / 100`;
            const feedback = document.getElementById('feedback');
            if (totalScore >= 90) {
                feedback.textContent = "太棒了！你真是个编程天才！";
                feedback.className = 'text-center text-lg mb-8 text-green-600 font-semibold';
            } else if (totalScore >= 70) {
                feedback.textContent = "非常不错！继续努力，你很有潜力！";
                feedback.className = 'text-center text-lg mb-8 text-blue-600 font-semibold';
            } else if (totalScore >= 60) {
                feedback.textContent = "成绩合格！在薄弱环节多下功夫，你会更棒！";
                feedback.className = 'text-center text-lg mb-8 text-yellow-600 font-semibold';
            } else {
                feedback.textContent = "别灰心，这只是一个开始。认真分析错题，你会进步的！";
                feedback.className = 'text-center text-lg mb-8 text-red-600 font-semibold';
            }
            document.getElementById('result-container').classList.remove('hidden');
            document.getElementById('submit-btn').style.display = 'none';

            // Disable all inputs
            form.querySelectorAll('input[type="radio"]').forEach(input => {
                input.disabled = true;
            });

            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    });

    </script>
</body>
</html>
