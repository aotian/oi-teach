<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速排序算法交互式详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Calm Red & Slate -->
    <!-- Application Structure Plan: A single-page, vertically scrolling layout following the established template: Core Concept, Interactive Visualization, Code Template, and Practice Problems. The core of this page is a step-by-step, interactive DOM-based animation visualizing the Lomuto partition scheme, which is central to Quicksort. -->
    <!-- Visualization & Content Choices:
        - Report Info: Quicksort Core Logic -> Goal: Explain the Divide and Conquer strategy via partitioning -> Viz: Structured text with lists -> Justification: A clear textual explanation of the three main phases (pivot, partition, recurse) is essential.
        - Report Info: Quicksort Partition Steps -> Goal: Show how the array is rearranged around a pivot -> Viz: Interactive DOM animation that highlights the pivot, i/j pointers, and elements being swapped -> Interaction: 'Next Step' button to control the animation pace -> Justification: The movement of pointers and swaps in the partition step is the most critical and non-trivial part of Quicksort, making a step-by-step visualizer invaluable. Method: DOM manipulation.
        - Report Info: C++ Implementation -> Goal: Provide a standard code template -> Viz: A styled code block with a copy button -> Interaction: Copy button -> Justification: Provides a practical, error-free way for students to get a standard recursive implementation.
        - Report Info: Practice -> Goal: Guide further learning to its classic applications -> Viz: Interactive cards linking to problems like 'K-th Number' (Quickselect) -> Justification: Connects the algorithm to its important applications beyond just sorting.
     -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        :root {
            --bg-main: #f3f4f6;
            --bg-card: #ffffff;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --accent-primary: #ef4444;
            --accent-secondary: #4f46e5;
            --border-color: #e5e7eb;
        }
        html { scroll-behavior: smooth; }
        body { background-color: var(--bg-main); color: var(--text-primary); }
        h2, h3 { color: var(--text-primary); font-weight: 700; }
        .code-block {
            background-color: #1f2937;
            color: #d1d5db;
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .copy-btn {
            position: absolute; top: 0.75rem; right: 0.75rem; background-color: #4b5563;
            color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            font-size: 0.875rem; cursor: pointer; transition: background-color 0.2s;
        }
        .copy-btn:hover { background-color: #6b7280; }
        button:disabled { background-color: #9ca3af; cursor: not-allowed; }

        /* Quick Sort Animation Styles */
        .array-container {
            display: flex;
            gap: 4px;
            padding: 8px 8px 40px 8px; /* Add padding at bottom for pointers */
            border-radius: 4px;
            min-height: 80px;
            align-items: center;
            position: relative;
        }
        .array-element {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e5e7eb;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }
        .element-pointer {
            position: absolute;
            bottom: -25px;
            font-size: 0.8rem;
            font-weight: bold;
            width: 100%;
            text-align: center;
        }
        .array-element.pivot { background-color: #fecaca; border-color: var(--accent-primary); }
        .array-element.sorted { background-color: #dcfce7; border-color: #4ade80; }
        .array-element.less { background-color: #dbeafe; border-color: var(--accent-secondary); }
    </style>
</head>
<body class="font-sans">

    <div id="main-content" class="container mx-auto px-4 py-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">快速排序 (Quick Sort) 算法详解</h1>
            <p class="text-lg text-gray-600 mt-2">最常用的高效排序算法</p>
        </header>

        <main class="space-y-8">
            <section id="section-concept" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">一、核心思想：分治与分区</h2>
                <p class="text-secondary mb-4">快速排序（Quick Sort）同样采用**分治（Divide and Conquer）**思想，被认为是实践中最高效的排序算法之一。它的平均时间复杂度为 O(n log n)。</p>
                <div class="grid md:grid-cols-3 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-2">1. 选择基准 (Pivot)</h3>
                        <p class="text-secondary">从数组中挑选一个元素作为“基准”或“主元”(pivot)。选择策略会影响算法性能，常见策略有：选择第一个元素、最后一个元素、中间元素，或随机选择。</p>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-2">2. 分区 (Partition)</h3>
                        <p class="text-secondary">重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于基准的元素移动到右边。分区操作结束后，该基准元素就处于其最终排序后的正确位置。</p>
                    </div>
                     <div>
                        <h3 class="text-xl font-semibold mb-2">3. 递归 (Recurse)</h3>
                        <p class="text-secondary">对基准左边的子数组和右边的子数组，递归地重复上述过程。</p>
                    </div>
                </div>
                 <div class="mt-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
                    <p><strong class="font-bold">性能提示：</strong> 快速排序的最坏情况（例如在已排序的数组上选择第一个元素为基准）时间复杂度会退化到 O(n²)。但在平均情况下，它的性能非常好，并且是**不稳定**的排序算法。</p>
                </div>
            </section>

            <section id="section-interactive" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">二、步进式交互动画</h2>
                <p class="text-secondary mb-4">下面的动画将分步演示快速排序如何处理序列 `[8, 4, 5, 7, 1, 3, 6, 2]`。我们将使用最后一个元素作为基准 (pivot)。请点击“下一步”来执行算法的每一个关键步骤。</p>
                <div class="flex space-x-4 mb-4">
                   <button id="run-quick-sort" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">下一步</button>
                   <button id="reset-quick-sort" class="w-full px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">重置</button>
                </div>
                <p id="quick-sort-status" class="text-center font-semibold mt-4 h-12"></p>
                <div id="quick-sort-vis" class="space-y-4"></div>
            </section>

            <section id="section-code" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">三、C++ 核心代码模板 (Lomuto 分区)</h2>
                <p class="text-secondary mb-4">这是竞赛中常用的递归实现版本，采用 Lomuto 分区方案（选择最后一个元素为基准）。</p>
                <div class="code-block">
                   <button class="copy-btn" onclick="copyCode(this)">复制</button>
                   <pre><code>#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Lomuto 分区函数
// 将小于等于 pivot 的元素放到左边，大于 pivot 的元素放到右边
// 返回 pivot 的最终位置
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 选择最后一个元素作为基准
    int i = (low - 1); // i 指向小于 pivot 区域的最后一个元素

    for (int j = low; j < high; j++) {
        // 如果当前元素小于或等于 pivot
        if (arr[j] <= pivot) {
            i++; // 扩展小于区域
            swap(arr[i], arr[j]);
        }
    }
    // 将 pivot 放到正确的位置
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // pi 是分区后基准元素的位置
        int pi = partition(arr, low, high);

        // 递归地对左右子数组进行排序
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    vector<int> arr = {8, 4, 5, 7, 1, 3, 6, 2};

    cout << "Original array: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    quickSort(arr, 0, arr.size() - 1);

    cout << "Sorted array:   ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
</code></pre>
                </div>
            </section>

             <section id="section-practice" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">四、实战演练</h2>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P1177 【模板】快速排序/归并排序</h4>
                        <p class="text-sm text-gray-600 my-2">练习快速排序算法的绝佳模板题。要求手写，禁止使用 `std::sort`。</p>
                        <a href="https://www.luogu.com.cn/problem/P1177" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">前往挑战</a>
                    </div>
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P1923 【模板】第k小数</h4>
                        <p class="text-sm text-gray-600 my-2">快速排序的经典应用——快速选择算法。思考如何利用 `partition` 函数的特性，每次只递归一边，在 O(n) 的平均时间内找到第k小的数。</p>
                        <a href="https://www.luogu.com.cn/problem/P1923" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">前往挑战</a>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
    // --- Code Copy ---
    function copyCode(button) {
        const pre = button.nextElementSibling;
        navigator.clipboard.writeText(pre.innerText).then(() => {
            const originalText = button.innerText;
            button.innerText = '已复制!';
            setTimeout(() => { button.innerText = originalText; }, 2000);
        });
    }

    // --- Quick Sort Visualization ---
    const visContainer = document.getElementById('quick-sort-vis');
    const statusEl = document.getElementById('quick-sort-status');
    const runBtn = document.getElementById('run-quick-sort');

    let array = [];
    let animationSteps = [];
    let currentStep = 0;

    function generateSteps(arr, low, high) {
        if (low < high) {
            const pivot = arr[high];
            let i = low - 1;
            animationSteps.push({ type: 'start_partition', range: [low, high] });

            for (let j = low; j < high; j++) {
                animationSteps.push({ type: 'compare', i, j, pivotIndex: high, range: [low, high] });
                if (arr[j] <= pivot) {
                    i++;
                    if (i !== j) {
                        animationSteps.push({ type: 'swap', indices: [i, j], i_ptr: i, j_ptr: j, pivotIndex: high, range: [low, high] });
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                }
            }
            const pi = i + 1;
            if (pi !== high) {
                animationSteps.push({ type: 'place_pivot', indices: [pi, high], range: [low, high] });
                [arr[pi], arr[high]] = [arr[high], arr[pi]];
            }
            animationSteps.push({ type: 'end_partition', pivotIndex: pi });

            generateSteps(arr, low, pi - 1);
            generateSteps(arr, pi + 1, high);
        } else if (low === high) {
             animationSteps.push({ type: 'single_element', index: low });
        }
    }
    
    function drawState(arr, step) {
        visContainer.innerHTML = '';
        const { type, range, i, j, pivotIndex, indices, index } = step;

        const container = document.createElement('div');
        container.className = 'array-container';
        
        arr.forEach((val, idx) => {
            const el = document.createElement('div');
            el.className = 'array-element';
            el.innerText = val;
            
            if (type === 'start_partition' && range && idx >= range[0] && idx <= range[1]) {
                if(idx === range[1]) el.classList.add('pivot');
            } else if ((type === 'compare' || type === 'swap' || type === 'place_pivot')) {
                if (idx === pivotIndex) el.classList.add('pivot');
                if (idx <= i) el.classList.add('less');
            } else if (type === 'end_partition' || type === 'single_element') {
                if (arr.every((v, k) => k === 0 || v >= arr[k-1])) {
                     el.classList.add('sorted');
                }
            }
            
            if (type === 'end_partition' && idx === pivotIndex) {
                 el.classList.add('sorted');
            }
             if (type === 'single_element' && idx === index) {
                 el.classList.add('sorted');
            }

            // Pointers
            if ((type === 'compare' || type === 'swap') && range) {
                if (idx === j) {
                    el.innerHTML += '<div class="element-pointer text-blue-500">j</div>';
                }
                if (idx === i && i >= range[0]) {
                    el.innerHTML += '<div class="element-pointer text-purple-500">i</div>';
                }
            }
            container.appendChild(el);
        });
        visContainer.appendChild(container);

        // Status Text
        if (type === 'start_partition') statusEl.innerText = `对区间 [${range[0]}, ${range[1]}] 进行分区，选择 ${arr[range[1]]} 为基准`;
        else if (type === 'compare') statusEl.innerText = `比较: arr[j=${j}] (${arr[j]}) <= pivot (${arr[pivotIndex]}) ?`;
        else if (type === 'swap') statusEl.innerText = `交换 arr[i=${indices[0]}] 和 arr[j=${indices[1]}]`;
        else if (type === 'place_pivot') statusEl.innerText = `将基准 ${arr[indices[1]]} 放到最终位置 ${indices[0]}`;
        else if (type === 'end_partition') statusEl.innerText = `分区完成, 基准 ${arr[pivotIndex]} 已就位`;
        else if (type === 'single_element') statusEl.innerText = `区间 [${index}] 只剩一个元素, 自然有序`;
    }

    function step() {
        if (currentStep < animationSteps.length) {
            const currentArrState = getArrayStateAtStep(currentStep);
            drawState(currentArrState, animationSteps[currentStep]);
            currentStep++;
        } else {
            statusEl.innerText = '排序完成!';
            runBtn.disabled = true;
            // Final sorted state
            const finalArr = getArrayStateAtStep(currentStep);
            visContainer.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'array-container';
            finalArr.forEach(val => {
                const el = document.createElement('div');
                el.className = 'array-element sorted'; // Add sorted class directly
                el.innerText = val;
                container.appendChild(el);
            });
            visContainer.appendChild(container);
        }
    }

    function getArrayStateAtStep(stepIndex) {
        let tempArr = [8, 4, 5, 7, 1, 3, 6, 2];
        for (let i = 0; i < stepIndex; i++) {
            const step = animationSteps[i];
            if (step.type === 'swap' || step.type === 'place_pivot') {
                [tempArr[step.indices[0]], tempArr[step.indices[1]]] = [tempArr[step.indices[1]], tempArr[step.indices[0]]];
            }
        }
        return tempArr;
    }

    function reset() {
        animationSteps = [];
        currentStep = 0;
        let tempArr = [8, 4, 5, 7, 1, 3, 6, 2];
        generateSteps(tempArr, 0, tempArr.length - 1);
        
        visContainer.innerHTML = '';
        const container = document.createElement('div');
        container.className = 'array-container';
        [8, 4, 5, 7, 1, 3, 6, 2].forEach(val => {
            const el = document.createElement('div');
            el.className = 'array-element';
            el.innerText = val;
            container.appendChild(el);
        });
        visContainer.appendChild(container);
        statusEl.innerText = '准备开始...';
        runBtn.disabled = false;
    }

    document.getElementById('run-quick-sort').addEventListener('click', step);
    document.getElementById('reset-quick-sort').addEventListener('click', reset);

    window.onload = () => {
       reset();
    };
</script>

</body>
</html>

