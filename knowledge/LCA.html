<!-- Chosen Palette: Warm Neutral Study -->
<!-- Application Structure Plan: The application follows a structured, four-part narrative designed for progressive learning. 1) **The Problem:** It starts with a relatable analogy (a family tree) to introduce the LCA problem and the inefficient 'naive' approach, establishing the need for a better solution. 2) **The Core Idea & Pre-computation:** This interactive section is the heart of the app. It visually demonstrates the 'doubling' concept by allowing the user to step through the creation of the `up` table. This demystifies the pre-computation phase, which is often the hardest part to grasp. 3) **The Query:** This second interactive part lets users apply the pre-computed table to solve LCA queries. It visualizes the binary jumps, making the logarithmic query time tangible. 4) **Recap & Code:** The final section provides a summary of the data structures, complexity analysis, and a practical C++ implementation. This structure—Problem, Solution Idea, Interactive Practice, and Formalization—is a proven pedagogical model for teaching complex algorithms. -->
<!-- Visualization & Content Choices: 
- Report Info: The concept of jumping up a tree. -> Goal: Contrast the slow, one-step-at-a-time method with a faster "doubling" method. -> Viz/Presentation Method: An interactive Canvas visualization of a tree. -> Interaction: User-controlled stepping to see the pre-computation of jump pointers. -> Justification: Canvas allows for dynamic highlighting of nodes and paths, visually representing the core idea of `up[i][j] = up[up[i][j-1]][j-1]` which is central to understanding the algorithm. NO SVG is used.
- Report Info: The pre-computed `up` table and `depth` array. -> Goal: Show the data structure that powers the fast queries. -> Viz/Presentation Method: A dynamically generated HTML `<table>`. -> Interaction: Table cells are highlighted in sync with the Canvas visualization during both pre-computation and querying steps. -> Justification: This creates a direct visual link between the abstract data in the table and its concrete application on the tree, reinforcing learning.
- Report Info: The LCA query algorithm. -> Goal: Demonstrate how to use the `up` table to find an LCA in O(log N) time. -> Viz/Presentation Method: Canvas visualization where nodes jump up the tree. -> Interaction: User selects two nodes, then steps through the process of equalizing depths and finding the LCA. -> Justification: Animating the jumps makes the efficiency of the logarithmic approach immediately obvious compared to the naive parent-by-parent climb.
- Report Info: C++ implementation. -> Goal: Provide a concrete, usable code example. -> Viz/Presentation Method: Styled `<pre><code>` block. -> Interaction: 'Copy Code' button. -> Justification: Offers students a practical takeaway to use in their own projects.
-->
<!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>倍增算法 (Binary Lifting) 交互式学习应用</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Hiragino Sans GB', 'WenQuanYi Micro Hei', 'Microsoft Yahei', sans-serif;
            background-color: #f5f5f4; /* stone-100 */
        }
        .content-card {
            background-color: #ffffff;
            border: 1px solid #e7e5e4; /* stone-200 */
            border-radius: 1.5rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .control-button {
            transition: all 0.2s ease-in-out;
        }
        .control-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .up-table th, .up-table td {
            transition: background-color 0.3s ease-in-out;
        }
        canvas { cursor: pointer; }
    </style>
</head>
<body class="text-stone-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">

        <header class="text-center mb-12">
            <h1 class="text-5xl font-extrabold text-stone-900 mb-4">倍增算法：学会瞬间移动</h1>
            <p class="text-xl text-stone-600 max-w-3xl mx-auto">在树上寻找祖先，一步一步太慢？让我们学习如何像开了传送门一样，实现 O(log N) 的高效查询。</p>
        </header>

        <section id="problem" class="content-card">
            <h2 class="text-3xl font-bold mb-4 text-stone-800">起点：一个家族的疑问</h2>
            <div class="prose max-w-none text-stone-700">
                <p>想象一棵巨大的家族树。现在任意挑选两个人，我们要找到他们“血缘关系最近的共同祖先”。这个问题，在信息学中被称为“最近公共祖先”（Lowest Common Ancestor, LCA）。</p>
                <p>最朴素的方法是什么？让其中较年轻的一个人，顺着家谱往上，一代一代地找自己的父辈、祖父辈……直到和另一个人的辈分相同。然后，两个人再一起，一代一代地同时往上找，直到他们遇到同一个人。这个方法简单，但如果家族树有成千上万代，每次查询都要“爬”很久，效率太低了。</p>
                <p><strong>我们的目标：</strong>有没有一种方法，可以预先“研究”一下家谱，然后就能非常快速地回答任何两个人的LCA查询？“倍增”就是答案。</p>
            </div>
        </section>

        <section id="interactive-demo" class="content-card">
            <h2 class="text-3xl font-bold mb-6 text-stone-800">核心：预处理与查询</h2>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div class="lg:col-span-2 rounded-2xl p-4 border border-stone-200 bg-stone-50 flex items-center justify-center">
                    <canvas id="tree-canvas" width="600" height="500"></canvas>
                </div>
                <div class="flex flex-col space-y-4">
                    <div class="p-4 rounded-xl border bg-stone-50">
                        <h3 class="text-xl font-semibold mb-3 text-stone-700">交互控制器</h3>
                        <div id="controls" class="flex flex-col space-y-3">
                             <button id="start-precompute-btn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-lg shadow-md control-button">1. 开始预处理</button>
                             <button id="next-step-btn" class="w-full bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-4 rounded-lg shadow-md control-button hidden">下一步</button>
                        </div>
                        <div id="query-controls" class="hidden mt-4 flex flex-col space-y-3">
                            <button id="select-nodes-btn" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-4 rounded-lg shadow-md control-button">2. 选择节点查LCA</button>
                             <button id="reset-btn" class="w-full bg-stone-500 hover:bg-stone-600 text-white font-bold py-3 px-4 rounded-lg shadow-md control-button">重置</button>
                        </div>
                    </div>
                    <div class="p-4 rounded-xl border bg-stone-50 flex-grow">
                        <h3 class="text-xl font-semibold text-stone-700 mb-2">状态面板</h3>
                        <div id="status-text" class="mt-2 text-stone-600 min-h-[6em] bg-white p-3 rounded-md border text-base">欢迎来到倍增算法学习中心。请首先进行“预处理”，为快速查询做准备。</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="data-structure" class="content-card">
            <h2 class="text-3xl font-bold mb-4 text-stone-800">倍增的基石：`up` 表</h2>
            <p class="prose max-w-none text-stone-700 mb-6">倍增的精髓在于一个预处理出来的表格，我们称之为 `up` 表。`up[i][j]` 存储的是节点 `i` 向上走 `2^j` 步所能到达的祖先。例如，`up[i][0]` 是 `i` 的父节点 (走2^0=1步)，`up[i][1]` 是 `i` 的祖父节点 (走2^1=2步)，`up[i][2]` 是 `i` 的曾曾祖父节点 (走2^2=4步)，以此类推。这个表可以通过 `up[i][j] = up[ up[i][j-1] ][j-1]` 这个神奇的公式高效计算出来。意思就是：我向上跳 `2^j` 步，等于先跳 `2^(j-1)` 步，再从落点继续跳 `2^(j-1)` 步。</p>
            <div class="overflow-x-auto">
                <table id="up-table" class="w-full text-center border-collapse up-table">
                    <!-- 表格将由JS生成 -->
                </table>
            </div>
        </section>

        <section id="code-and-complexity" class="content-card">
             <h2 class="text-3xl font-bold mb-4 text-stone-800">效率分析与 C++ 实现</h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <div class="prose max-w-none text-stone-700">
                        <p>倍增算法的强大之处在于其时间复杂度：</p>
                        <ul class="list-disc list-inside space-y-2">
                            <li><strong>预处理：</strong> 我们需要填充 `up` 表和 `depth` 数组。对于 N 个节点，`up` 表的大小约为 N * logN。填充整个表的时间复杂度是 <strong class="text-amber-600">O(N log N)</strong>。</li>
                            <li><strong>查询：</strong> 借助 `up` 表，每次查询 LCA 只需要一系列logN级别的跳跃。因此，单次查询的时间复杂度是 <strong class="text-amber-600">O(log N)</strong>。</li>
                        </ul>
                        <p>这是一种典型的“空间换时间”策略。我们通过一次性的预处理，换来了后续无数次超快速的查询。</p>
                    </div>
                </div>
                <div>
                    <div class="relative">
                        <button id="copy-btn" class="absolute top-2 right-2 bg-stone-200 hover:bg-stone-300 text-stone-700 text-xs font-bold py-1 px-2 rounded">复制</button>
                        <pre class="bg-stone-800 text-white p-4 rounded-lg text-sm overflow-x-auto"><code id="code-block" class="language-cpp">#include &lt;vector&gt;
#include &lt;cmath&gt;

const int MAXN = 1000;
const int LOGN = 10; // ceil(log2(MAXN))
std::vector&lt;int&gt; adj[MAXN];
int depth[MAXN], up[MAXN][LOGN];

void dfs(int u, int p, int d) {
    depth[u] = d;
    up[u][0] = p;
    for (int v : adj[u]) {
        if (v != p) {
            dfs(v, u, d + 1);
        }
    }
}

void precompute(int N) {
    dfs(0, -1, 0); // Assuming root is 0
    for (int j = 1; j < LOGN; ++j) {
        for (int i = 0; i < N; ++i) {
            if (up[i][j-1] != -1) {
                up[i][j] = up[up[i][j-1]][j-1];
            } else {
                up[i][j] = -1;
            }
        }
    }
}

int lca(int u, int v) {
    if (depth[u] < depth[v]) std::swap(u, v);
    for (int j = LOGN - 1; j >= 0; --j) {
        if (depth[u] - (1 << j) >= depth[v]) {
            u = up[u][j];
        }
    }
    if (u == v) return u;
    for (int j = LOGN - 1; j >= 0; --j) {
        if (up[u][j] != -1 && up[u][j] != up[v][j]) {
            u = up[u][j];
            v = up[v][j];
        }
    }
    return up[u][0];
}
</code></pre>
                    </div>
                </div>
            </div>
        </section>
    </div>

<script>
const nodes = [
    { id: 0, name: 'A', x: 300, y: 50, depth: 0 },
    { id: 1, name: 'B', x: 150, y: 150, depth: 1 }, { id: 2, name: 'C', x: 450, y: 150, depth: 1 },
    { id: 3, name: 'D', x: 70, y: 250, depth: 2 }, { id: 4, name: 'E', x: 230, y: 250, depth: 2 },
    { id: 5, name: 'F', x: 380, y: 250, depth: 2 }, { id: 6, name: 'G', x: 530, y: 250, depth: 2 },
    { id: 7, name: 'H', x: 120, y: 350, depth: 3 }, { id: 8, name: 'I', x: 280, y: 350, depth: 3 },
    { id: 9, name: 'J', x: 430, y: 350, depth: 3 },
    { id: 10, name: 'K', x: 220, y: 450, depth: 4 }
];
const adj = { 0:[1,2], 1:[3,4], 2:[5,6], 3:[], 4:[7,8], 5:[9], 6:[], 7:[], 8:[10], 9:[], 10:[] };
const N = nodes.length;
const LOGN = Math.ceil(Math.log2(N));

let state = {};

const canvas = document.getElementById('tree-canvas');
const ctx = canvas.getContext('2d');
const startPrecomputeBtn = document.getElementById('start-precompute-btn');
const nextStepBtn = document.getElementById('next-step-btn');
const selectNodesBtn = document.getElementById('select-nodes-btn');
const resetBtn = document.getElementById('reset-btn');
const queryControls = document.getElementById('query-controls');
const statusTextEl = document.getElementById('status-text');
const upTableEl = document.getElementById('up-table');
const copyBtn = document.getElementById('copy-btn');
const codeBlock = document.getElementById('code-block');

function initialize() {
    state = {
        phase: 'init', // init, precomputing, select, querying, done
        depth: new Array(N).fill(0),
        up: Array.from({ length: N }, () => new Array(LOGN).fill(-1)),
        precomputeState: { i: 0, j: 1 },
        queryState: { u: -1, v: -1, lca: -1, subPhase: 'start', j: LOGN - 1 },
        highlight: { nodes: [], edges: [], tableCells: [] }
    };
    startPrecomputeBtn.disabled = false;
    startPrecomputeBtn.classList.remove('hidden');
    nextStepBtn.classList.add('hidden');
    queryControls.classList.add('hidden');
    selectNodesBtn.disabled = true;
    updateStatus('欢迎! 请点击按钮开始预处理。');
    runDFS(0, -1, 0);
    draw();
    drawUpTable();
}

function runDFS(u, p, d) {
    state.depth[u] = d;
    state.up[u][0] = p;
    nodes[u].depth = d;
    for (const v of (adj[u] || [])) {
        if (v !== p) runDFS(v, u, d + 1);
    }
}

function handleNextStep() {
    if (state.phase === 'precomputing') {
        precomputeStep();
    } else if (state.phase === 'querying') {
        queryStep();
    }
}

function precomputeStep() {
    let { i, j } = state.precomputeState;

    const parent_i_j_minus_1 = state.up[i][j - 1];
    state.up[i][j] = (parent_i_j_minus_1 !== -1) ? state.up[parent_i_j_minus_1][j - 1] : -1;
    
    updateStatus(`计算 up[${nodes[i].name}][${j}] = up[up[${nodes[i].name}][${j-1}]][${j-1}]`);
    
    state.highlight.nodes = [i];
    state.highlight.tableCells = [`cell-${i}-${j}`, `cell-${i}-${j-1}`];
    if(parent_i_j_minus_1 !== -1) {
        state.highlight.nodes.push(parent_i_j_minus_1);
        state.highlight.tableCells.push(`cell-${parent_i_j_minus_1}-${j-1}`);
    }

    draw();
    drawUpTable();
    
    i++;
    if (i >= N) {
        i = 0;
        j++;
    }
    
    if (j >= LOGN) {
        state.phase = 'select';
        startPrecomputeBtn.textContent = '预处理完成!';
        nextStepBtn.classList.add('hidden');
        queryControls.classList.remove('hidden');
        selectNodesBtn.disabled = false;
        updateStatus('预处理完成！现在您可以选择两个节点来查找它们的LCA。');
        state.highlight = { nodes: [], edges: [], tableCells: [] };
        draw();
        return;
    }
    state.precomputeState = { i, j };
}

function handleSelectNodes() {
    state.phase = 'selecting';
    state.queryState = { u: -1, v: -1, lca: -1, subPhase: 'start', j: LOGN - 1 };
    updateStatus('请在左侧画布上点击选择两个节点。');
    state.highlight = { nodes: [], edges: [], tableCells: [] };
    selectNodesBtn.disabled = true;
    draw();
}

function handleCanvasClick(event) {
    if (state.phase !== 'selecting') return;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    for (const node of nodes) {
        const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
        if (dist < 20) {
            if (state.queryState.u === -1) {
                state.queryState.u = node.id;
                updateStatus(`已选择节点 ${nodes[node.id].name}。请选择第二个节点。`);
            } else if (state.queryState.v === -1 && state.queryState.u !== node.id) {
                state.queryState.v = node.id;
                state.phase = 'querying';
                updateStatus(`已选择 ${nodes[state.queryState.u].name} 和 ${nodes[state.queryState.v].name}。点击“下一步”开始查找LCA。`);
                nextStepBtn.classList.remove('hidden');
            }
            draw();
            break;
        }
    }
}

function queryStep() {
    let { u, v, subPhase, j } = state.queryState;
    if (state.depth[u] < state.depth[v]) [u, v] = [v, u];

    if(subPhase === 'start') {
        state.queryState.u = u;
        state.queryState.v = v;
        subPhase = 'equalizing';
        state.queryState.subPhase = subPhase;
    }

    if (subPhase === 'equalizing') {
        if (state.depth[u] === state.depth[v]) {
            state.queryState.subPhase = 'checking_identity';
            j = LOGN - 1;
            state.queryState.j = j;
            queryStep(); // Immediately move to next phase
            return;
        }
        for (; j >= 0; j--) {
            if (state.depth[u] - (1 << j) >= state.depth[v]) {
                const next_u = state.up[u][j];
                updateStatus(`深度不同, 将 ${nodes[u].name} 向上跳 2^${j}=${1<<j} 步到 ${nodes[next_u].name}`);
                state.highlight = { nodes: [u, next_u], edges: [], tableCells: [`cell-${u}-${j}`]};
                state.queryState.u = next_u;
                state.queryState.j = j - 1;
                draw();
                drawUpTable();
                return;
            }
        }
        state.queryState.j = j; // Update j if loop finishes
    }
    
    u = state.queryState.u;
    v = state.queryState.v;
    subPhase = state.queryState.subPhase;

    if (subPhase === 'checking_identity') {
         if (u === v) {
            state.queryState.lca = u;
            state.queryState.subPhase = 'done';
            updateStatus(`LCA 找到! 是 ${nodes[u].name}。`);
            state.highlight = { nodes: [u], edges: [], tableCells: [] };
            nextStepBtn.classList.add('hidden');
            draw();
            return;
        } else {
            state.queryState.subPhase = 'jumping';
            queryStep(); // Immediately move to next phase
            return;
        }
    }

    if (state.queryState.subPhase === 'jumping') {
        for (; j >= 0; j--) {
            if (state.up[u][j] !== -1 && state.up[u][j] !== state.up[v][j]) {
                const next_u = state.up[u][j];
                const next_v = state.up[v][j];
                updateStatus(`共同向上跳 2^${j}=${1<<j} 步。${nodes[u].name} -> ${nodes[next_u].name}, ${nodes[v].name} -> ${nodes[next_v].name}`);
                state.highlight = { nodes: [u, v, next_u, next_v], edges: [], tableCells: [`cell-${u}-${j}`, `cell-${v}-${j}`] };
                state.queryState.u = next_u;
                state.queryState.v = next_v;
                state.queryState.j = j - 1;
                draw();
                drawUpTable();
                return;
            }
        }
        // After loop, the LCA is the parent of u
        const lca = state.up[u][0];
        state.queryState.lca = lca;
        state.queryState.subPhase = 'done';
        updateStatus(`LCA 找到! 是 ${nodes[lca].name}。`);
        state.highlight = { nodes: [lca], edges: [], tableCells: [] };
        nextStepBtn.classList.add('hidden');
        draw();
    }
}


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw edges
    for (let u = 0; u < N; u++) {
        for (const v of (adj[u] || [])) {
            if (u < v) { // Avoid drawing twice
                ctx.beginPath();
                ctx.moveTo(nodes[u].x, nodes[u].y);
                ctx.lineTo(nodes[v].x, nodes[v].y);
                ctx.strokeStyle = '#d6d3d1';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }
    
    // Draw nodes
    for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
        let fill = '#a8a29e'; // stone-400
        if(state.queryState.u === node.id || state.queryState.v === node.id) fill = '#2dd4bf'; // teal-400
        if(state.queryState.lca === node.id) fill = '#f59e0b'; // amber-500
        if(state.highlight.nodes.includes(node.id)) fill = '#60a5fa'; // blue-400
        
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = '#44403c';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(node.name, node.x, node.y);
    }
}

function drawUpTable() {
    let html = '<thead><tr class="bg-stone-200"><th class="p-2 border">Node</th>';
    for(let j=0; j<LOGN; j++) {
        html += `<th class="p-2 border">2^${j}</th>`;
    }
    html += '</tr></thead><tbody>';
    for(let i=0; i<N; i++) {
        html += `<tr><td class="p-2 border font-bold bg-stone-100">${nodes[i].name}</td>`;
        for(let j=0; j<LOGN; j++) {
            const val = state.up[i][j];
            const cellId = `cell-${i}-${j}`;
            let highlightClass = state.highlight.tableCells.includes(cellId) ? 'bg-sky-200' : '';
            html += `<td id="${cellId}" class="p-2 border ${highlightClass}">${val === -1 ? '-' : nodes[val].name}</td>`;
        }
        html += '</tr>';
    }
    html += '</tbody>';
    upTableEl.innerHTML = html;
}

function updateStatus(text) { statusTextEl.textContent = text; }

startPrecomputeBtn.addEventListener('click', () => {
    state.phase = 'precomputing';
    startPrecomputeBtn.disabled = true;
    startPrecomputeBtn.classList.add('hidden');
    nextStepBtn.classList.remove('hidden');
    updateStatus('准备就绪，点击“下一步”开始填充 up 表。');
});

nextStepBtn.addEventListener('click', handleNextStep);
selectNodesBtn.addEventListener('click', handleSelectNodes);
resetBtn.addEventListener('click', initialize);
canvas.addEventListener('click', handleCanvasClick);
copyBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(codeBlock.innerText).then(() => {
        copyBtn.textContent = '已复制!';
        setTimeout(() => { copyBtn.textContent = '复制'; }, 2000);
    });
});

window.onload = initialize;
</script>
</body>
</html>

