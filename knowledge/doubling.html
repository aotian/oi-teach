<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式倍增(Doubling)算法学习教案</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Helvetica Neue', 'Arial', 'sans-serif';
            scroll-behavior: smooth;
        }
        .step-log-item {
            transition: all 0.3s ease-in-out;
            opacity: 0;
            transform: translateY(10px);
        }
        .step-log-item.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .log-container-view {
            background-color: #1f2937; /* gray-800 */
            color: white;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border-radius: 0.5rem;
            min-height: 150px;
            font-size: 0.875rem;
        }
        .log-comment { color: #9ca3af; /* gray-400 */ }
        .tab-button {
            transition: all 0.2s ease;
        }
        .tab-button.active {
            border-color: #3b82f6;
            color: #3b82f6;
        }
        .tree-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .tree-node:hover circle {
            stroke-width: 4;
            stroke: #60a5fa; /* blue-400 */
        }
        .tree-node.selected circle {
            fill: #3b82f6; /* blue-500 */
            stroke: #1d4ed8; /* blue-700 */
            stroke-width: 3;
        }
        .tree-node.selected text {
            fill: white;
            font-weight: bold;
        }
        .tree-node.highlight-lca circle {
             fill: #22c55e; /* green-500 */
             stroke: #15803d; /* green-700 */
        }
        .tree-path {
            transition: all 0.5s ease;
            stroke-dasharray: 200;
            stroke-dashoffset: 200;
        }
        .tree-path.draw {
            stroke-dashoffset: 0;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <!-- Header and Navigation -->
    <header class="bg-white shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-3 flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800">信息学竞赛算法课：倍增</h1>
            <div class="hidden md:flex space-x-4">
                <a href="#intro" class="text-gray-600 hover:text-blue-500">引入</a>
                <a href="#preprocessing" class="text-gray-600 hover:text-blue-500">预处理</a>
                <a href="#lca-visualizer" class="text-gray-600 hover:text-blue-500">LCA应用</a>
                <a href="#code" class="text-gray-600 hover:text-blue-500">核心代码</a>
                <a href="#practice" class="text-gray-600 hover:text-blue-500">在线练习</a>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-6 md:p-8">

        <!-- Section 1: Introduction -->
        <section id="intro" class="bg-white p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-bold mb-4">1. 思想引入：如何快速找到祖先？</h2>
            <p class="mb-4 text-gray-600">假设你有一张巨大的家谱（一棵树），你想知道某个人（节点）的第 13 代祖先是谁。你会怎么做？</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-red-50 p-6 rounded-lg">
                    <h3 class="font-bold text-lg mb-2 text-red-700">常规方法</h3>
                    <p>一步一步往上找，找 13 次父亲。如果 K 很大，比如要找第 1000 代祖先，效率就很低。<b>时间复杂度 O(K)</b>。</p>
                </div>
                <div class="bg-green-50 p-6 rounded-lg">
                    <h3 class="font-bold text-lg mb-2 text-green-700">倍增思想</h3>
                    <p>我们可以像二进制拆分一样“跳着走”！ 任何数字 K 都可以用 2 的幂次组合而成。例如 <b>13 = 8 + 4 + 1</b>。</p>
                    <p class="mt-2">我们只需要先跳 8 步，再跳 4 步，最后跳 1 步。总共只需 3 次跳跃！<b>时间复杂度 O(log K)</b>。</p>
                </div>
            </div>
            <p class="mt-6 text-gray-600">为了实现快速跳跃，我们需要提前“预处理”出每个节点向上跳 $2^0=1$ 步、 $2^1=2$ 步、 $2^2=4$ 步、 $2^3=8$ 步... 分别能到达哪个祖先。这个预处理的过程，就是倍增算法的核心。</p>
        </section>

        <!-- Section 2: Preprocessing Visualizer -->
        <section id="preprocessing" class="bg-white p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-bold mb-4">2. 核心环节：预处理与倍增表</h2>
            <p class="mb-4 text-gray-600">我们用一个二维数组 `fa[i][j]` 来存储预处理结果，它表示**节点 i 向上走 $2^j$ 步所到达的祖先**。</p>
            <p class="mb-6 text-gray-600">这个表有一个神奇的递推关系：<b>`fa[i][j] = fa[ fa[i][j-1] ][ j-1 ]`</b>。 意思是：<b>i 的 $2^j$ 代祖先 = (i 的 $2^{j-1}$ 代祖先) 的 $2^{j-1}$ 代祖先</b>。 (例如：$2^3 = 2^2 + 2^2$)</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                     <svg id="preprocess-tree" class="w-full h-auto border rounded-lg" viewBox="0 0 400 300"></svg>
                </div>
                <div>
                    <button id="start-preprocess-btn" class="w-full bg-blue-500 text-white font-semibold px-6 py-2 rounded-lg hover:bg-blue-600 transition mb-4">开始可视化预处理</button>
                    <div class="log-container-view">
                        <p class="log-comment">// 预处理日志...</p>
                        <div id="preprocess-log"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: LCA Visualizer -->
        <section id="lca-visualizer" class="bg-white p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-bold mb-4">3. 经典应用：最近公共祖先 (LCA)</h2>
            <p class="mb-4 text-gray-600">LCA 是树上两个节点所有公共祖先中，深度最浅的一个。利用倍增可以高效求解。</p>
            <p class="mb-6 text-gray-600"><b>步骤：</b> 1. 将深度较深的节点跳到与另一节点相同的高度。 2. 如果两节点重合，则它就是LCA。 3. 否则，两节点同时向上“同步跳跃”，直到它们的父节点相同。这个父节点就是LCA。</p>
             <div class="grid md:grid-cols-2 gap-8">
                <div class="relative">
                    <svg id="lca-tree" class="w-full h-auto border rounded-lg" viewBox="0 0 500 450"></svg>
                    <p id="lca-tooltip" class="absolute bg-gray-800 text-white text-sm rounded-md px-2 py-1 pointer-events-none opacity-0 transition-opacity"></p>
                </div>
                <div>
                    <div class="bg-gray-100 p-4 rounded-lg">
                        <p class="font-medium">请在左侧树上选择两个节点 (u, v):</p>
                        <div class="flex items-center gap-4 my-2">
                           <span class="font-bold">u = <span id="u-node-label">-</span></span>
                           <span class="font-bold">v = <span id="v-node-label">-</span></span>
                        </div>
                        <button id="find-lca-btn" class="w-full bg-green-500 text-white font-semibold px-6 py-2 rounded-lg hover:bg-green-600 transition mb-2" disabled>开始查找LCA</button>
                        <button id="reset-lca-btn" class="w-full bg-gray-300 text-gray-700 font-semibold px-6 py-2 rounded-lg hover:bg-gray-400 transition">重置选择</button>
                    </div>
                    <div class="log-container-view mt-4">
                        <p class="log-comment">// LCA 查找日志...</p>
                        <div id="lca-log"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Code Templates -->
        <section id="code" class="bg-white p-8 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-bold mb-4">4. 核心代码模板 (C++)</h2>
            <div class="flex justify-center mb-4 border-b">
                <button class="tab-button active px-4 py-2 font-semibold border-b-2" data-target="code-preprocess">预处理</button>
                <button class="tab-button px-4 py-2 font-semibold" data-target="code-lca">LCA查询</button>
            </div>
            <div id="code-preprocess">
                 <pre><code class="language-cpp bg-gray-800 text-white p-4 rounded-lg block overflow-x-auto">
// N: 节点数, LOGN: log2(N)的最大值
int fa[N][LOGN], depth[N];
vector&lt;int&gt; adj[N];

// 1. DFS: 计算深度和直接父节点
void dfs(int u, int p) {
    depth[u] = depth[p] + 1;
    fa[u][0] = p;
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
    }
}

// 2. 主函数中调用
void preprocess() {
    // 假设1为根节点, 深度为1, 父节点为0
    dfs(1, 0); 

    // 填充倍增表
    for (int j = 1; j < LOGN; ++j) {
        for (int i = 1; i <= N; ++i) {
            fa[i][j] = fa[ fa[i][j-1] ][ j-1 ];
        }
    }
}
                </code></pre>
            </div>
            <div id="code-lca" class="hidden">
                <pre><code class="language-cpp bg-gray-800 text-white p-4 rounded-lg block overflow-x-auto">
int lca(int u, int v) {
    // 1. 保证 u 的深度 >= v 的深度
    if (depth[u] < depth[v]) swap(u, v);

    // 2. 将 u 跳到和 v 相同的高度
    for (int j = LOGN - 1; j >= 0; --j) {
        if (depth[fa[u][j]] >= depth[v]) {
            u = fa[u][j];
        }
    }

    // 3. 如果 v 是 u 的祖先, v 就是LCA
    if (u == v) return u;

    // 4. 同步向上跳, 直到父节点相同
    for (int j = LOGN - 1; j >= 0; --j) {
        if (fa[u][j] != fa[v][j]) {
            u = fa[u][j];
            v = fa[v][j];
        }
    }

    // 5. 父节点即为LCA
    return fa[u][0];
}
                </code></pre>
            </div>
        </section>

        <!-- Section 5: Practice -->
        <section id="practice" class="bg-white p-8 rounded-xl shadow-lg">
            <h2 class="text-2xl font-bold mb-4">5. 上手练习，巩固知识</h2>
            <p class="mb-6 text-gray-600">推荐使用 <a href="https://www.luogu.com.cn/" target="_blank" class="text-blue-500 font-bold hover:underline">洛谷 (Luogu)</a> 平台进行练习。</p>
            <div class="space-y-4">
                <a href="https://www.luogu.com.cn/problem/P3379" target="_blank" class="block bg-blue-50 p-4 rounded-lg hover:bg-blue-100 transition">
                    <p class="font-semibold text-blue-800">核心模板：洛谷 P3379 【模板】最近公共祖先 (LCA)</p>
                    <p class="text-sm text-blue-600">练习LCA的经典模板题，必须掌握。</p>
                </a>
                <a href="https://www.luogu.com.cn/problem/P3865" target="_blank" class="block bg-yellow-50 p-4 rounded-lg hover:bg-yellow-100 transition">
                    <p class="font-semibold text-yellow-800">拓展应用：洛谷 P3865 【模板】ST表</p>
                    <p class="text-sm text-yellow-600">ST表是倍增思想在序列区间最值问题(RMQ)上的应用，查询效率高达O(1)。</p>
                </a>
                 <a href="https://www.luogu.com.cn/problem/P1967" target="_blank" class="block bg-green-50 p-4 rounded-lg hover:bg-green-100 transition">
                    <p class="font-semibold text-green-800">综合应用：洛谷 P1967 [NOIP2013 提高组] 货车运输</p>
                    <p class="text-sm text-green-600">将倍增LCA与图论(最大生成树)结合的经典题目，可以综合考察算法能力。</p>
                </a>
            </div>
        </section>

    </main>
    <footer class="text-center py-6 text-sm text-gray-500">
        <p>祝同学们在信息学竞赛中取得优异成绩！</p>
    </footer>

<script>
    // --- Utility function for adding logs ---
    function addLog(container, message, delay) {
        return new Promise(resolve => {
            setTimeout(() => {
                const logItem = document.createElement('p');
                logItem.textContent = `> ${message}`;
                logItem.className = 'step-log-item';
                container.appendChild(logItem);
                setTimeout(() => logItem.classList.add('visible'), 50);
                container.scrollTop = container.scrollHeight;
                resolve();
            }, delay);
        });
    }

    // --- Tab Switcher for Code Section ---
    document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', () => {
            const targetId = button.dataset.target;
            document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
            button.classList.add('active');
            
            button.parentElement.nextElementSibling.childNodes.forEach(child => {
                 if (child.nodeType === 1) { // Check if it's an element
                    if (child.id === targetId) {
                        child.classList.remove('hidden');
                    } else {
                        child.classList.add('hidden');
                    }
                 }
            });
        });
    });

    // --- Part 2: Preprocessing Visualizer ---
    (function() {
        const svg = document.getElementById('preprocess-tree');
        const logContainer = document.getElementById('preprocess-log');
        const startBtn = document.getElementById('start-preprocess-btn');
        const ns = 'http://www.w3.org/2000/svg';
        
        const nodes = {
            1: { x: 200, y: 30 }, 2: { x: 100, y: 100 }, 3: { x: 300, y: 100 },
            4: { x: 50, y: 170 }, 5: { x: 150, y: 170 }, 6: { x: 250, y: 170 }, 7: { x: 350, y: 170 },
            8: { x: 25, y: 240 }, 9: { x: 75, y: 240 }
        };
        const edges = [[1,2], [1,3], [2,4], [2,5], [3,6], [3,7], [4,8], [4,9]];
        const LOGN = 4; // ceil(log2(9))
        const N = 9;
        let fa = Array(N + 1).fill(0).map(() => Array(LOGN).fill(0));
        let depth = Array(N + 1).fill(0);
        let adj = Array(N + 1).fill(0).map(() => []);
        edges.forEach(([u,v]) => { adj[u].push(v); adj[v].push(u); });

        function dfs(u, p, d) {
            depth[u] = d;
            fa[u][0] = p;
            for (const v of adj[u]) {
                if (v !== p) dfs(v, u, d + 1);
            }
        }

        function drawTree() {
            svg.innerHTML = '';
            edges.forEach(([u, v]) => {
                const line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', nodes[u].x); line.setAttribute('y1', nodes[u].y);
                line.setAttribute('x2', nodes[v].x); line.setAttribute('y2', nodes[v].y);
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2);
                svg.appendChild(line);
            });
            Object.keys(nodes).forEach(id => {
                const g = document.createElementNS(ns, 'g');
                const circle = document.createElementNS(ns, 'circle');
                circle.setAttribute('id', `prep-node-${id}`);
                circle.setAttribute('cx', nodes[id].x); circle.setAttribute('cy', nodes[id].y);
                circle.setAttribute('r', 15); circle.setAttribute('fill', '#fff');
                circle.setAttribute('stroke', '#4b5563'); circle.setAttribute('stroke-width', 2);
                const text = document.createElementNS(ns, 'text');
                text.setAttribute('x', nodes[id].x); text.setAttribute('y', nodes[id].y + 5);
                text.setAttribute('text-anchor', 'middle'); text.textContent = id;
                g.appendChild(circle); g.appendChild(text);
                svg.appendChild(g);
            });
        }
        
        async function animateNode(id, color, duration = 500) {
            const node = document.getElementById(`prep-node-${id}`);
            if(node) {
                node.setAttribute('fill', color);
                await new Promise(r => setTimeout(r, duration));
                node.setAttribute('fill', '#fff');
            }
        }

        async function startAnimation() {
            startBtn.disabled = true;
            logContainer.innerHTML = '';
            drawTree();
            dfs(1, 0, 1);

            await addLog(logContainer, '1. DFS完成, 计算出depth和fa[i][0](直接父节点)', 500);

            for (let j = 1; j < LOGN; j++) {
                await addLog(logContainer, `2. 开始计算 j = ${j} (即向上跳 2^${j} = ${1<<j} 步)`, 500);
                for (let i = 1; i <= N; i++) {
                     if (fa[i][j-1] !== 0) {
                        const p1 = fa[i][j-1];
                        const p2 = fa[p1][j-1];
                        await addLog(logContainer, `  计算 fa[${i}][${j}] = fa[fa[${i}][${j-1}]][${j-1}]`, 300);
                        await addLog(logContainer, `    = fa[${p1}][${j-1}] = ${p2}`, 300);
                        animateNode(i, '#fde047');
                        animateNode(p1, '#60a5fa');
                        await animateNode(p2, '#4ade80', 1000);
                     }
                }
            }
             await addLog(logContainer, `3. 预处理完成！`, 500);
             startBtn.disabled = false;
        }

        startBtn.addEventListener('click', startAnimation);
        drawTree();
    })();
    
    // --- Part 3: LCA Visualizer ---
    (function() {
        const svg = document.getElementById('lca-tree');
        const logContainer = document.getElementById('lca-log');
        const findBtn = document.getElementById('find-lca-btn');
        const resetBtn = document.getElementById('reset-lca-btn');
        const uLabel = document.getElementById('u-node-label');
        const vLabel = document.getElementById('v-node-label');
        const tooltip = document.getElementById('lca-tooltip');
        const ns = 'http://www.w3.org/2000/svg';
        
        const nodes = {
            1: { x: 250, y: 30 }, 2: { x: 125, y: 100 }, 3: { x: 375, y: 100 },
            4: { x: 62.5, y: 170 }, 5: { x: 187.5, y: 170 }, 6: { x: 312.5, y: 170 }, 7: { x: 437.5, y: 170 },
            8: { x: 31.25, y: 240 }, 9: { x: 93.75, y: 240 }, 10: { x: 156.25, y: 240 }, 11: { x: 218.75, y: 240 },
            12: { x: 281.25, y: 310 }, 13: { x: 343.75, y: 310 }, 14: { x: 406.25, y: 380 }, 15: { x: 468.75, y: 380 }
        };
        const edges = [[1,2],[1,3],[2,4],[2,5],[3,6],[3,7],[4,8],[4,9],[5,10],[5,11],[6,12],[6,13],[7,14],[7,15]];
        const N = 15;
        const LOGN = 4; // ceil(log2(15))
        let fa = Array(N + 1).fill(0).map(() => Array(LOGN).fill(0));
        let depth = Array(N + 1).fill(0);
        let adj = Array(N + 1).fill(0).map(() => []);
        edges.forEach(([u,v]) => { adj[u].push(v); adj[v].push(u); });

        let selectedU = null, selectedV = null;

        function dfs(u, p, d) {
            depth[u] = d;
            fa[u][0] = p;
            for (const v of adj[u]) {
                if (v !== p) dfs(v, u, d + 1);
            }
        }
        
        function preprocess() {
            dfs(1, 0, 1);
            for (let j = 1; j < LOGN; ++j) {
                for (let i = 1; i <= N; ++i) {
                    fa[i][j] = fa[fa[i][j - 1]][j - 1];
                }
            }
        }
        
        function drawTree() {
            svg.innerHTML = '';
             edges.forEach(([u, v]) => {
                const line = document.createElementNS(ns, 'line');
                line.setAttribute('id', `line-${u}-${v}`);
                line.setAttribute('x1', nodes[u].x); line.setAttribute('y1', nodes[u].y);
                line.setAttribute('x2', nodes[v].x); line.setAttribute('y2', nodes[v].y);
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2);
                svg.appendChild(line);
            });
            Object.keys(nodes).forEach(id => {
                const g = document.createElementNS(ns, 'g');
                g.classList.add('tree-node');
                g.setAttribute('id', `lca-node-${id}`);
                g.dataset.id = id;
                const circle = document.createElementNS(ns, 'circle');
                circle.setAttribute('cx', nodes[id].x); circle.setAttribute('cy', nodes[id].y);
                circle.setAttribute('r', 15); circle.setAttribute('fill', '#fff');
                circle.setAttribute('stroke', '#4b5563'); circle.setAttribute('stroke-width', 2);
                const text = document.createElementNS(ns, 'text');
                text.setAttribute('x', nodes[id].x); text.setAttribute('y', nodes[id].y + 5);
                text.setAttribute('text-anchor', 'middle'); text.textContent = id;
                g.appendChild(circle); g.appendChild(text);
                svg.appendChild(g);
            });
            addEventListeners();
        }
        
        function addEventListeners() {
            document.querySelectorAll('.tree-node').forEach(nodeEl => {
                nodeEl.addEventListener('click', handleNodeClick);
                nodeEl.addEventListener('mouseenter', e => {
                    const id = e.currentTarget.dataset.id;
                    tooltip.textContent = `节点: ${id}, 深度: ${depth[id]}`;
                    tooltip.style.left = `${nodes[id].x + 20}px`;
                    tooltip.style.top = `${nodes[id].y}px`;
                    tooltip.style.opacity = 1;
                });
                 nodeEl.addEventListener('mouseleave', () => {
                    tooltip.style.opacity = 0;
                });
            });
        }
        
        function handleNodeClick(e) {
            const id = parseInt(e.currentTarget.dataset.id);
            if (!selectedU) {
                selectedU = id;
                uLabel.textContent = id;
                e.currentTarget.classList.add('selected');
            } else if (!selectedV && id !== selectedU) {
                selectedV = id;
                vLabel.textContent = id;
                e.currentTarget.classList.add('selected');
                findBtn.disabled = false;
            }
        }

        async function animatePath(u, v, color) {
            const path = document.createElementNS(ns, 'path');
            path.setAttribute('d', `M ${nodes[u].x} ${nodes[u].y} L ${nodes[v].x} ${nodes[v].y}`);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '4');
            path.setAttribute('fill', 'none');
            path.classList.add('tree-path');
            svg.insertBefore(path, svg.firstChild);
            await new Promise(r => setTimeout(r, 50));
            path.classList.add('draw');
            await new Promise(r => setTimeout(r, 500));
            return path;
        }
        
        async function findLCA() {
            findBtn.disabled = true;
            resetBtn.disabled = true;
            logContainer.innerHTML = '';
            
            let u = selectedU, v = selectedV;
            await addLog(logContainer, `开始查找LCA(${u}, ${v})`, 200);
            
            if (depth[u] < depth[v]) [u, v] = [v, u];
            await addLog(logContainer, `1. 保证u(${u})深度(${depth[u]}) >= v(${v})深度(${depth[v]})`, 500);

            if(depth[u] > depth[v]){
                await addLog(logContainer, `2. 将u跳到和v相同的高度`, 500);
                for (let j = LOGN - 1; j >= 0; --j) {
                    if (depth[fa[u][j]] >= depth[v]) {
                        const next_u = fa[u][j];
                        await addLog(logContainer, `  尝试跳2^${j}=${1<<j}步: ${u} -> ${next_u}`, 800);
                        const path = await animatePath(u, next_u, '#f59e0b');
                        u = next_u;
                        document.getElementById(`lca-node-${u}`).classList.add('selected');
                        path.remove();
                    }
                }
            }

            if (u === v) {
                await addLog(logContainer, `节点重合, LCA是 ${u}`, 500);
                document.getElementById(`lca-node-${u}`).classList.add('highlight-lca');
            } else {
                 await addLog(logContainer, `3. 同步向上跳跃`, 500);
                 for (let j = LOGN - 1; j >= 0; --j) {
                    if (fa[u][j] !== fa[v][j]) {
                        const next_u = fa[u][j];
                        const next_v = fa[v][j];
                        await addLog(logContainer, `  尝试跳2^${j}步: ${u}->${next_u}, ${v}->${next_v}`, 800);
                        const path_u = await animatePath(u, next_u, '#f59e0b');
                        const path_v = await animatePath(v, next_v, '#f59e0b');
                        u = next_u; v = next_v;
                        document.getElementById(`lca-node-${u}`).classList.add('selected');
                        document.getElementById(`lca-node-${v}`).classList.add('selected');
                        path_u.remove(); path_v.remove();
                    }
                }
                const lcaNode = fa[u][0];
                await addLog(logContainer, `4. 父节点 ${lcaNode} 即为LCA`, 500);
                document.getElementById(`lca-node-${lcaNode}`).classList.add('highlight-lca');
            }
             resetBtn.disabled = false;
        }

        function resetLCA() {
            document.querySelectorAll('.tree-node').forEach(n => n.classList.remove('selected', 'highlight-lca'));
            selectedU = null; selectedV = null;
            uLabel.textContent = '-'; vLabel.textContent = '-';
            logContainer.innerHTML = '';
            findBtn.disabled = true;
        }

        findBtn.addEventListener('click', findLCA);
        resetBtn.addEventListener('click', resetLCA);
        
        preprocess();
        drawTree();
    })();

</script>
</body>
</html>
