<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra 算法交互式详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Calm Indigo & Green -->
    <!-- Application Structure Plan: A single-page, vertically scrolling layout is chosen for this detailed algorithm explanation. It is structured into four logical parts: Core Concept, Interactive Visualization, Code Template, and Practice Problems. This linear flow guides the user from theory to practice. The centerpiece is the interactive DOM-based graph visualization, which is crucial for understanding Dijkstra's step-by-step process. -->
    <!-- Visualization & Content Choices:
        - Report Info: Dijkstra's Core Logic -> Goal: Explain the greedy strategy -> Viz: Structured text with lists and analogies -> Justification: A clear, well-explained textual overview is necessary before diving into visualization.
        - Report Info: Dijkstra's Algorithm Steps -> Goal: Show the process of node selection and edge relaxation -> Viz: Interactive DOM graph animation -> Interaction: 'Run' button animates node highlighting, edge checks, and distance updates -> Justification: Makes the abstract algorithm tangible and easy to follow. Method: DOM manipulation.
        - Report Info: C++ Implementation -> Goal: Provide an optimized, competition-ready code template -> Viz: A styled code block with a copy button -> Interaction: Copy button -> Justification: Provides a practical, error-free way for students to get the standard implementation.
        - Report Info: Practice -> Goal: Guide further learning -> Viz: Interactive cards linking to online judge problems -> Justification: Connects learning with immediate application.
     -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        :root {
            --bg-main: #f3f4f6;
            --bg-card: #ffffff;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --accent-primary: #4f46e5;
            --accent-secondary: #059669;
            --border-color: #e5e7eb;
        }
        html { scroll-behavior: smooth; }
        body { background-color: var(--bg-main); color: var(--text-primary); }
        h2, h3 { color: var(--text-primary); font-weight: 700; }
        .code-block {
            background-color: #1f2937;
            color: #d1d5db;
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .copy-btn {
            position: absolute; top: 0.75rem; right: 0.75rem; background-color: #4b5563;
            color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            font-size: 0.875rem; cursor: pointer; transition: background-color 0.2s;
        }
        .copy-btn:hover { background-color: #6b7280; }
        .graph-container {
            position: relative; width: 100%; height: 350px; background-color: #f9fafb;
            border: 1px solid var(--border-color); border-radius: 0.5rem;
        }
        .graph-node {
            position: absolute; width: 44px; height: 44px; border-radius: 50%;
            background-color: #d1d5db; border: 2px solid #6b7280; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            font-weight: bold; color: #374151; transition: all 0.3s ease;
            transform: translate(-50%, -50%); font-size: 0.9rem;
        }
        .graph-node .dist { font-size: 0.7rem; color: #4b5563; }
        .graph-node.source { background-color: #34d399; border-color: #059669; }
        .graph-node.visited { background-color: #a5b4fc; border-color: #6366f1; }
        .graph-node.current { background-color: #facc15; border-color: #f59e0b; transform: translate(-50%, -50%) scale(1.15); }
        .graph-edge {
            position: absolute; background-color: #9ca3af; height: 2px;
            transform-origin: 0 0; transition: all 0.3s ease;
        }
        .edge-label {
            position: absolute; background-color: #f9fafb; color: #4b5563;
            font-size: 0.75rem; padding: 0 3px;
        }
        .graph-edge.checking { background-color: var(--accent-primary); height: 4px; }
    </style>
</head>
<body class="font-sans">

    <div id="main-content" class="container mx-auto px-4 py-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">迪杰斯特拉 (Dijkstra) 算法详解</h1>
            <p class="text-lg text-gray-600 mt-2">单源最短路径问题的贪心之王</p>
        </header>

        <main class="space-y-8">
            <section id="section-concept" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">一、核心思想：贪心策略</h2>
                <p class="text-secondary mb-4">Dijkstra 算法是一种用于解决**无负权边**图的单源最短路径问题的经典算法。它的核心思想是一种**贪心策略**：</p>
                <div class="space-y-4">
                    <p>1.  **初始化：** 创建一个距离数组 `dist`，`dist[s]` (源点) 初始化为0，其他所有点为无穷大。创建一个集合 `S`，用于存放已确定最短路径的点。</p>
                    <p>2.  **选择最近点：** 从未被访问过的点中，选择一个 `dist` 值最小的点 `u`。这个贪心选择是算法的关键，它相信当前 `dist` 最小的点，其最短路径已经不可能再被优化了。</p>
                    <p>3.  **加入集合：** 将点 `u` 加入集合 `S`，表示 `u` 的最短路径已确定。</p>
                    <p>4.  **松弛操作：** 遍历从 `u` 出发的所有边 `(u, v)`，如果经过 `u` 到达 `v` 的路径比已知的 `dist[v]` 更短 (即 `dist[u] + weight(u, v) < dist[v]`)，就更新 `dist[v]` 的值。</p>
                    <p>5.  **重复：** 重复步骤 2-4，直到所有点都被加入集合 `S`。</p>
                </div>
                <div class="mt-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-800">
                    <p><strong class="font-bold">重要限制：</strong>Dijkstra 的贪心策略依赖于边的权重为非负数。如果图中存在负权边，算法可能会得出错误的结果。对于带负权边的图，需要使用 Bellman-Ford 或 SPFA 算法。</p>
                </div>
            </section>

            <section id="section-interactive" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">二、交互式动画演示</h2>
                <p class="text-secondary mb-4">下面的动画将演示堆优化的Dijkstra算法如何从源点 `1` 开始，一步步找到到所有其他节点的最短路径。</p>
                <div class="grid lg:grid-cols-2 gap-8 items-center">
                    <div>
                        <button id="run-dijkstra" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition mb-4">运行动画</button>
                        <button id="reset-dijkstra" class="w-full px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">重置</button>
                        <p id="dijkstra-status" class="text-center font-semibold mt-4 h-12"></p>
                    </div>
                    <div id="dijkstra-graph" class="graph-container"></div>
                </div>
            </section>

            <section id="section-code" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">三、C++ 核心代码模板 (堆优化)</h2>
                <p class="text-secondary mb-4">这是竞赛中常用的堆优化版本，时间复杂度为 O(E log N)。注意 `INF` 的定义，使用 `0x3f3f3f3f` 是一个常用技巧，它足够大，并且两个 `INF` 相加不会溢出 `int`。</p>
                <div class="code-block">
                   <button class="copy-btn" onclick="copyCode(this)">复制</button>
                   <pre><code>#include <iostream>
#include <vector>
#include <queue>
#include <cstring> // For memset

using namespace std;

const int INF = 0x3f3f3f3f;
const int N = 100005; // 节点数上限

struct Edge {
    int to;
    int weight;
};

vector<Edge> adj[N];
int dist[N];
bool visited[N];

void dijkstra(int start_node, int n) {
    memset(dist, 0x3f, sizeof(dist));
    memset(visited, false, sizeof(visited));
    
    dist[start_node] = 0;
    
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start_node});

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        for (const auto& edge : adj[u]) {
            int v = edge.to;
            int weight = edge.weight;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n = 6, m = 9; // 节点数, 边数
    
    // 添加边...
    adj[1].push_back({2, 7}); adj[2].push_back({1, 7});
    adj[1].push_back({3, 9}); adj[3].push_back({1, 9});
    adj[1].push_back({6, 14}); adj[6].push_back({1, 14});
    adj[2].push_back({3, 10}); adj[3].push_back({2, 10});
    adj[2].push_back({4, 15}); adj[4].push_back({2, 15});
    adj[3].push_back({6, 2}); adj[6].push_back({3, 2});
    adj[3].push_back({4, 11}); adj[4].push_back({3, 11});
    adj[4].push_back({5, 6}); adj[5].push_back({4, 6});
    adj[5].push_back({6, 9}); adj[6].push_back({5, 9});

    int start_node = 1;
    dijkstra(start_node, n);

    cout << "从源点 " << start_node << " 出发的最短路径：" << endl;
    for (int i = 1; i <= n; ++i) {
        cout << "到节点 " << i << " 的距离: ";
        if (dist[i] == INF) {
            cout << "不可达" << endl;
        } else {
            cout << dist[i] << endl;
        }
    }
    
    return 0;
}
</code></pre>
                </div>
            </section>

             <section id="section-practice" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">四、实战演练</h2>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P3371 【模板】单源最短路径</h4>
                        <p class="text-sm text-gray-600 my-2">练习堆优化的 Dijkstra 算法的绝佳模板题。</p>
                        <a href="https://www.luogu.com.cn/problem/P3371" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">前往挑战</a>
                    </div>
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P1339 [USACO09JAN] 热浪</h4>
                        <p class="text-sm text-gray-600 my-2">Dijkstra 算法的直接应用，题目背景稍作包装，本质不变。</p>
                        <a href="https://www.luogu.com.cn/problem/P1339" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">前往挑战</a>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
    let isAnimating = false;
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    // --- Code Copy ---
    function copyCode(button) {
        const pre = button.nextElementSibling;
        navigator.clipboard.writeText(pre.innerText).then(() => {
            const originalText = button.innerText;
            button.innerText = '已复制!';
            setTimeout(() => { button.innerText = originalText; }, 2000);
        });
    }

    // --- Dijkstra Visualization ---
    const dijkstraGraph = document.getElementById('dijkstra-graph');
    const dijkstraStatus = document.getElementById('dijkstra-status');
    const nodes = [
        {x: 50, y: 175}, {x: 150, y: 50}, {x: 150, y: 300}, 
        {x: 250, y: 50}, {x: 250, y: 300}, {x: 350, y: 175}
    ];
    const edges = [
        {from: 0, to: 1, weight: 7}, {from: 0, to: 2, weight: 9},
        {from: 1, to: 3, weight: 10}, {from: 1, to: 2, weight: 15},
        {from: 2, to: 4, weight: 11},
        {from: 3, to: 4, weight: 2}, {from: 3, to: 5, weight: 6},
        {from: 4, to: 5, weight: 9}
    ];
    const adj = Array.from({length: nodes.length}, () => []);
    edges.forEach(e => {
        adj[e.from].push({ to: e.to, weight: e.weight });
        adj[e.to].push({ to: e.from, weight: e.weight });
    });

    let nodeElements = {};
    let edgeElements = {};

    function drawGraph() {
        dijkstraGraph.innerHTML = '';
        nodeElements = {};
        edgeElements = {};

        edges.forEach(edge => {
            const n1 = nodes[edge.from];
            const n2 = nodes[edge.to];
            const angle = Math.atan2(n2.y - n1.y, n2.x - n1.x) * 180 / Math.PI;
            const length = Math.sqrt(Math.pow(n2.x - n1.x, 2) + Math.pow(n2.y - n1.y, 2));

            const edgeEl = document.createElement('div');
            edgeEl.id = `edge-${edge.from}-${edge.to}`;
            edgeEl.className = 'graph-edge';
            edgeEl.style.left = `${n1.x}px`;
            edgeEl.style.top = `${n1.y}px`;
            edgeEl.style.width = `${length}px`;
            edgeEl.style.transform = `rotate(${angle}deg)`;
            dijkstraGraph.appendChild(edgeEl);
            edgeElements[`${edge.from}-${edge.to}`] = edgeEl;
            edgeElements[`${edge.to}-${edge.from}`] = edgeEl;

            const label = document.createElement('div');
            label.className = 'edge-label';
            label.innerText = edge.weight;
            label.style.left = `${(n1.x + n2.x)/2 - 5}px`;
            label.style.top = `${(n1.y + n2.y)/2 - 10}px`;
            dijkstraGraph.appendChild(label);
        });

        nodes.forEach((node, i) => {
            const nodeEl = document.createElement('div');
            nodeEl.id = `node-${i}`;
            nodeEl.className = 'graph-node';
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;
            nodeEl.innerHTML = `${i+1}<span class="dist">(∞)</span>`;
            dijkstraGraph.appendChild(nodeEl);
            nodeElements[i] = nodeEl;
        });
    }

    async function animateDijkstra() {
        if (isAnimating) return;
        isAnimating = true;
        drawGraph();
        dijkstraStatus.innerText = "动画开始...";

        const dist = Array(nodes.length).fill(Infinity);
        const visited = Array(nodes.length).fill(false);
        const startNode = 0;
        
        dist[startNode] = 0;
        nodeElements[startNode].innerHTML = `${startNode+1}<span class="dist">(0)</span>`;
        nodeElements[startNode].classList.add('source');

        const pq = [{ dist: 0, node: startNode }];

        while (pq.length > 0) {
            pq.sort((a, b) => a.dist - b.dist);
            const { node: u } = pq.shift();

            if (visited[u]) continue;
            
            dijkstraStatus.innerText = `选择距离最短的节点: ${u+1} (距离=${dist[u]})`;
            nodeElements[u].classList.add('current');
            await sleep(1500);

            visited[u] = true;
            nodeElements[u].classList.remove('current');
            nodeElements[u].classList.add('visited');

            for (const { to: v, weight } of adj[u]) {
                const edgeEl = edgeElements[`${u}-${v}`];
                if (!visited[v] && dist[u] + weight < dist[v]) {
                     dijkstraStatus.innerText = `松弛节点 ${v+1}: 发现更短路径 ${dist[u]} + ${weight} = ${dist[u] + weight}`;
                     if(edgeEl) edgeEl.classList.add('checking');
                     await sleep(2000);

                    dist[v] = dist[u] + weight;
                    nodeElements[v].innerHTML = `${v+1}<span class="dist">(${dist[v]})</span>`;
                    pq.push({ dist: dist[v], node: v });
                     if(edgeEl) edgeEl.classList.remove('checking');
                }
            }
        }
        dijkstraStatus.innerText = "完成！所有节点最短路径已找到。";
        isAnimating = false;
    }
    
    document.getElementById('run-dijkstra').addEventListener('click', animateDijkstra);
    document.getElementById('reset-dijkstra').addEventListener('click', () => {
        if(isAnimating) return;
        dijkstraStatus.innerText = '';
        drawGraph();
    });

    window.onload = () => {
        drawGraph();
    };
</script>

</body>
</html>

