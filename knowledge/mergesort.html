<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>归并排序算法交互式详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Calm Blue & Purple -->
    <!-- Application Structure Plan: A single-page, vertically scrolling layout following the established template: Core Concept, Interactive Visualization, Code Template, and Practice Problems. This linear flow is effective for teaching a single, specific algorithm. The core of this page is a step-by-step, interactive DOM-based animation that visualizes both the 'divide' and 'merge' phases of Merge Sort, which is critical for understanding its recursive nature and the merging logic. -->
    <!-- Visualization & Content Choices:
        - Report Info: Merge Sort Core Logic -> Goal: Explain the Divide and Conquer strategy -> Viz: Structured text with lists -> Justification: A clear textual explanation of the two main phases is essential before showing the animation.
        - Report Info: Merge Sort Algorithm Steps -> Goal: Show the recursive splitting and iterative merging process -> Viz: Interactive DOM animation that uses nested divs to represent array splits and highlights elements during merging -> Interaction: 'Next Step' button to control the animation pace -> Justification: A step-by-step visualization is far superior to a video for teaching this algorithm, as it allows students to process each decision (split or merge) at their own pace. Method: DOM manipulation.
        - Report Info: C++ Implementation -> Goal: Provide a standard code template -> Viz: A styled code block with a copy button -> Interaction: Copy button -> Justification: Provides a practical, error-free way for students to get the standard recursive implementation.
        - Report Info: Practice -> Goal: Guide further learning, especially to its classic application -> Viz: Interactive cards linking to problems like 'Inversion Count' -> Justification: Connects the algorithm to one of its most important applications beyond simple sorting.
     -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        :root {
            --bg-main: #f3f4f6;
            --bg-card: #ffffff;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --border-color: #e5e7eb;
        }
        html { scroll-behavior: smooth; }
        body { background-color: var(--bg-main); color: var(--text-primary); }
        h2, h3 { color: var(--text-primary); font-weight: 700; }
        .code-block {
            background-color: #1f2937;
            color: #d1d5db;
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        .copy-btn {
            position: absolute; top: 0.75rem; right: 0.75rem; background-color: #4b5563;
            color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            font-size: 0.875rem; cursor: pointer; transition: background-color 0.2s;
        }
        .copy-btn:hover { background-color: #6b7280; }
        button:disabled { background-color: #9ca3af; cursor: not-allowed; }

        /* Merge Sort Animation Styles */
        .array-container {
            display: flex;
            gap: 4px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #f9fafb;
            min-height: 50px;
            align-items: center;
        }
        .array-element {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e5e7eb;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .highlight-divide {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .highlight-merge-left {
            background-color: #c7d2fe;
            border-color: #818cf8;
        }
        .highlight-merge-right {
             background-color: #d8b4fe;
            border-color: #c084fc;
        }
        .highlight-compare {
            transform: translateY(-10px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="font-sans">

    <div id="main-content" class="container mx-auto px-4 py-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">归并排序 (Merge Sort) 算法详解</h1>
            <p class="text-lg text-gray-600 mt-2">分治思想的完美体现</p>
        </header>

        <main class="space-y-8">
            <section id="section-concept" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">一、核心思想：分而治之</h2>
                <p class="text-secondary mb-4">归并排序（Merge Sort）是建立在**分治（Divide and Conquer）**思想上的一个高效、稳定的排序算法。它的逻辑就像整理一大堆试卷一样清晰：</p>
                <div class="grid md:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-semibold mb-2">1. 分解 (Divide)</h3>
                        <p class="text-secondary">不断地把需要排序的序列从中间分成两半，直到每个子序列只剩下一个元素。显然，只有一个元素的序列本身就是有序的。</p>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-2">2. 合并 (Conquer / Merge)</h3>
                        <p class="text-secondary">将两个已经排好序的子序列，合并成一个大的有序序列。这一步是归并排序的核心，通过双指针法，每次从两个子序列的头部取出较小的元素放入新序列，直到一个子序列为空，再将另一个子序列剩余部分直接拼接到新序列末尾。</p>
                    </div>
                </div>
                 <div class="mt-6 p-4 bg-green-50 border-l-4 border-green-400 text-green-800">
                    <p><strong class="font-bold">主要优点：</strong> 归并排序是一种**稳定**的排序算法（相同元素的相对位置不会改变），且时间复杂度始终为 O(n log n)，不受输入数据的影响。</p>
                </div>
            </section>

            <section id="section-interactive" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">二、步进式交互动画</h2>
                <p class="text-secondary mb-4">下面的动画将分步演示归并排序如何处理序列 `[8, 4, 5, 7, 1, 3, 6, 2]`。请点击“下一步”来执行算法的每一个关键步骤。</p>
                <div class="flex space-x-4 mb-4">
                   <button id="run-merge-sort" class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">下一步</button>
                   <button id="reset-merge-sort" class="w-full px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">重置</button>
                </div>
                <p id="merge-sort-status" class="text-center font-semibold mt-4 h-12"></p>
                <div id="merge-sort-vis" class="space-y-2"></div>
            </section>

            <section id="section-code" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">三、C++ 核心代码模板</h2>
                <p class="text-secondary mb-4">这是竞赛中常用的递归实现版本。注意 `merge` 函数需要一个辅助数组 `temp` 来存放合并后的结果。</p>
                <div class="code-block">
                   <button class="copy-btn" onclick="copyCode(this)">复制</button>
                   <pre><code>#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void merge(vector<int>& arr, int left, int mid, int right, vector<int>& temp) {
    int i = left;     // 左子数组起始索引
    int j = mid + 1;  // 右子数组起始索引
    int t = 0;        // temp数组起始索引

    // 1. 将两个有序子数组合并到temp数组
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[t++] = arr[i++];
        } else {
            temp[t++] = arr[j++];
        }
    }

    // 2. 将剩余的元素（如果有）复制到temp数组
    while (i <= mid) {
        temp[t++] = arr[i++];
    }
    while (j <= right) {
        temp[t++] = arr[j++];
    }

    // 3. 将temp数组的内容复制回原数组的对应位置
    t = 0;
    for (int k = left; k <= right; ++k) {
        arr[k] = temp[t++];
    }
}

void mergeSort(vector<int>& arr, int left, int right, vector<int>& temp) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    // 分解
    mergeSort(arr, left, mid, temp);
    mergeSort(arr, mid + 1, right, temp);
    // 合并
    merge(arr, left, mid, right, temp);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    vector<int> arr = {8, 4, 5, 7, 1, 3, 6, 2};
    vector<int> temp(arr.size());

    cout << "Original array: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    mergeSort(arr, 0, arr.size() - 1, temp);

    cout << "Sorted array:   ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    return 0;
}
</code></pre>
                </div>
            </section>

             <section id="section-practice" class="bg-white p-6 md:p-8 rounded-lg shadow-md">
                <h2 class="text-2xl mb-4 border-b pb-2">四、实战演练</h2>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P1177 【模板】快速排序/归并排序</h4>
                        <p class="text-sm text-gray-600 my-2">练习归并排序算法的绝佳模板题。要求手写，禁止使用 `std::sort`。</p>
                        <a href="https://www.luogu.com.cn/problem/P1177" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">前往挑战</a>
                    </div>
                    <div class="border rounded-lg p-4 bg-gray-50 hover:shadow-lg transition">
                        <h4 class="font-bold text-lg">P1908 逆序对</h4>
                        <p class="text-sm text-gray-600 my-2">归并排序最经典的应用。思考在 `merge` 过程中，当右子数组的元素 `arr[j]` 被放入 `temp` 数组时，它与左子数组中还剩下多少个元素构成了逆序对。</p>
                        <a href="https://www.luogu.com.cn/problem/P1908" target="_blank" class="block w-full text-center mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">前往挑战</a>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
    let isStepInProgress = false;

    // --- Code Copy ---
    function copyCode(button) {
        const pre = button.nextElementSibling;
        navigator.clipboard.writeText(pre.innerText).then(() => {
            const originalText = button.innerText;
            button.innerText = '已复制!';
            setTimeout(() => { button.innerText = originalText; }, 2000);
        });
    }

    // --- Merge Sort Visualization ---
    const visContainer = document.getElementById('merge-sort-vis');
    const statusEl = document.getElementById('merge-sort-status');
    const runBtn = document.getElementById('run-merge-sort');

    let initialArray = [8, 4, 5, 7, 1, 3, 6, 2];
    let animationSteps = [];
    let currentStep = 0;

    function generateSteps(arr, left, right) {
        if (left >= right) {
            return;
        }
        animationSteps.push({ type: 'divide', range: [left, right] });
        let mid = Math.floor(left + (right - left) / 2);
        generateSteps(arr, left, mid);
        generateSteps(arr, mid + 1, right);
        animationSteps.push({ type: 'merge_start', range: [left, mid, right] });
        
        let i = left, j = mid + 1;
        let temp = [];
        
        while (i <= mid && j <= right) {
            animationSteps.push({ type: 'compare', indices: [i, j] });
            if (arr[i] <= arr[j]) {
                temp.push(arr[i++]);
            } else {
                temp.push(arr[j++]);
            }
        }
        while (i <= mid) temp.push(arr[i++]);
        while (j <= right) temp.push(arr[j++]);

        for (let k = 0; k < temp.length; k++) {
            arr[left + k] = temp[k];
        }
        animationSteps.push({ type: 'merge_end', range: [left, right], sortedSubarray: temp });
    }

    function drawState(step) {
        visContainer.innerHTML = '';
        const { type, range, indices, sortedSubarray } = step;

        let levelMap = new Map();
        let queue = [{ l: 0, r: initialArray.length - 1, level: 0 }];
        levelMap.set('0-7', 0);
        let maxLevel = 0;

        while(queue.length > 0){
            let {l, r, level} = queue.shift();
            maxLevel = Math.max(maxLevel, level);
            if(l < r){
                let m = Math.floor(l + (r - l) / 2);
                queue.push({l, r: m, level: level + 1});
                levelMap.set(`${l}-${m}`, level + 1);
                queue.push({l: m + 1, r, level: level + 1});
                levelMap.set(`${m+1}-${r}`, level + 1);
            }
        }
        
        for(let i=0; i <= maxLevel * 2; i++) {
            const div = document.createElement('div');
            div.id = `level-${i}`;
            div.className = 'array-container justify-center';
            visContainer.appendChild(div);
        }

        const mainArrayDiv = document.getElementById('level-0');
        initialArray.forEach(val => {
            const el = document.createElement('div');
            el.className = 'array-element';
            el.innerText = val;
            mainArrayDiv.appendChild(el);
        });

        if (type === 'divide') {
            statusEl.innerText = `分解: 将区间 [${range[0]}, ${range[1]}] 分成两半`;
            const level = levelMap.get(`${range[0]}-${range[1]}`);
            const mid = Math.floor(range[0] + (range[1] - range[0]) / 2);
            
            const leftChildDiv = document.getElementById(`level-${level+1}`);
            const rightChildDiv = document.getElementById(`level-${level+1}`);

            for(let i=range[0]; i <= mid; i++){
                const el = document.createElement('div');
                el.className = 'array-element highlight-divide';
                el.innerText = initialArray[i];
                leftChildDiv.appendChild(el);
            }
            // add spacer
            const spacer = document.createElement('div');
            spacer.style.width = '20px';
            leftChildDiv.appendChild(spacer);
             for(let i=mid+1; i <= range[1]; i++){
                const el = document.createElement('div');
                el.className = 'array-element highlight-divide';
                el.innerText = initialArray[i];
                rightChildDiv.appendChild(el);
            }

        } else if (type === 'merge_start') {
            statusEl.innerText = `合并: 准备合并区间 [${range[0]}, ${range[1]}] 和 [${range[1]+1}, ${range[2]}]`;
             const level = levelMap.get(`${range[0]}-${range[2]}`);
             const mergeLevelDiv = document.getElementById(`level-${level + maxLevel +1}`);
             for(let i=range[0]; i <= range[2]; i++){
                 const el = document.createElement('div');
                 el.className = 'array-element';
                 el.innerText = '?';
                 if(i >= range[0] && i <= range[1]) el.classList.add('highlight-merge-left');
                 if(i > range[1] && i <= range[2]) el.classList.add('highlight-merge-right');
                 mergeLevelDiv.appendChild(el);
             }
        } else if(type === 'compare') {
             statusEl.innerText = `比较: arr[${indices[0]}] (${initialArray[indices[0]]}) 和 arr[${indices[1]}] (${initialArray[indices[1]]})`;
             const mainElements = mainArrayDiv.children;
             mainElements[indices[0]].classList.add('highlight-compare', 'highlight-merge-left');
             mainElements[indices[1]].classList.add('highlight-compare', 'highlight-merge-right');
        } else if(type === 'merge_end') {
            statusEl.innerText = `完成合并区间 [${range[0]}, ${range[1]}]`;
            for(let i = range[0]; i <= range[1]; i++) {
                initialArray[i] = sortedSubarray[i-range[0]];
            }
            const currentMainDiv = document.getElementById('level-0');
            for(let i = range[0]; i <= range[1]; i++) {
                currentMainDiv.children[i].innerText = initialArray[i];
                currentMainDiv.children[i].classList.add('bg-green-200', 'border-green-400');
            }
        }
    }

    function step() {
        if (currentStep < animationSteps.length) {
            drawState(animationSteps[currentStep]);
            currentStep++;
        } else {
            statusEl.innerText = '排序完成!';
            runBtn.disabled = true;
        }
    }

    function reset() {
        isStepInProgress = false;
        animationSteps = [];
        currentStep = 0;
        let tempArr = [...initialArray];
        generateSteps(tempArr, 0, tempArr.length - 1);
        visContainer.innerHTML = '';
        const mainArrayDiv = document.createElement('div');
        mainArrayDiv.id = 'level-0';
        mainArrayDiv.className = 'array-container justify-center';
        initialArray.forEach(val => {
            const el = document.createElement('div');
            el.className = 'array-element';
            el.innerText = val;
            mainArrayDiv.appendChild(el);
        });
        visContainer.appendChild(mainArrayDiv);
        statusEl.innerText = '准备开始...';
        runBtn.disabled = false;
    }

    document.getElementById('run-merge-sort').addEventListener('click', step);
    document.getElementById('reset-merge-sort').addEventListener('click', reset);

    window.onload = () => {
       reset();
    };
</script>

</body>
</html>
